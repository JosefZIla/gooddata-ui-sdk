// (C) 2022 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { addFlattenedObjectTo, assertParamExists } from './common';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Identifier of a user or user-group.
 * @export
 * @interface AssigneeIdentifier
 */
export interface AssigneeIdentifier {
    /**
     *
     * @type {string}
     * @memberof AssigneeIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AssigneeIdentifier
     */
    type: AssigneeIdentifierTypeEnum;
}

export const AssigneeIdentifierTypeEnum = {
    USER: "user",
    USER_GROUP: "userGroup",
} as const;

export type AssigneeIdentifierTypeEnum =
    typeof AssigneeIdentifierTypeEnum[keyof typeof AssigneeIdentifierTypeEnum];

/**
 * An id of the table from PDM mapped to this dataset. Including ID of data source.
 * @export
 * @interface DataSourceTableIdentifier
 */
export interface DataSourceTableIdentifier {
    /**
     * ID of table.
     * @type {string}
     * @memberof DataSourceTableIdentifier
     */
    id: string;
    /**
     * Data source ID.
     * @type {string}
     * @memberof DataSourceTableIdentifier
     */
    dataSourceId: string;
    /**
     * Data source entity type.
     * @type {string}
     * @memberof DataSourceTableIdentifier
     */
    type: DataSourceTableIdentifierTypeEnum;
}

export const DataSourceTableIdentifierTypeEnum = {
    DATA_SOURCE: "dataSource",
} as const;

export type DataSourceTableIdentifierTypeEnum =
    typeof DataSourceTableIdentifierTypeEnum[keyof typeof DataSourceTableIdentifierTypeEnum];

/**
 *
 * @export
 * @interface DatasetReferenceIdentifier
 */
export interface DatasetReferenceIdentifier {
    /**
     *
     * @type {string}
     * @memberof DatasetReferenceIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof DatasetReferenceIdentifier
     */
    type: DatasetReferenceIdentifierTypeEnum;
}

export const DatasetReferenceIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type DatasetReferenceIdentifierTypeEnum =
    typeof DatasetReferenceIdentifierTypeEnum[keyof typeof DatasetReferenceIdentifierTypeEnum];

/**
 *
 * @export
 * @interface DeclarativeAnalyticalDashboard
 */
export interface DeclarativeAnalyticalDashboard {
    /**
     * Analytical dashboard ID.
     * @type {string}
     * @memberof DeclarativeAnalyticalDashboard
     */
    id: string;
    /**
     * Analytical dashboard title.
     * @type {string}
     * @memberof DeclarativeAnalyticalDashboard
     */
    title: string;
    /**
     * Analytical dashboard description.
     * @type {string}
     * @memberof DeclarativeAnalyticalDashboard
     */
    description?: string;
    /**
     * A server agnostic definition of the dashboard plugin in JSON format.
     * @type {object}
     * @memberof DeclarativeAnalyticalDashboard
     */
    content: object;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeAnalyticalDashboard
     */
    tags?: Array<string>;
}
/**
 * Entities describing users\' view on data.
 * @export
 * @interface DeclarativeAnalytics
 */
export interface DeclarativeAnalytics {
    /**
     *
     * @type {DeclarativeAnalyticsLayer}
     * @memberof DeclarativeAnalytics
     */
    analytics?: DeclarativeAnalyticsLayer;
}
/**
 *
 * @export
 * @interface DeclarativeAnalyticsLayer
 */
export interface DeclarativeAnalyticsLayer {
    /**
     * A list of analytical dashboards available in the model.
     * @type {Array<DeclarativeAnalyticalDashboard>}
     * @memberof DeclarativeAnalyticsLayer
     */
    analyticalDashboards?: Array<DeclarativeAnalyticalDashboard>;
    /**
     * A list of filter contexts available in the model.
     * @type {Array<DeclarativeFilterContext>}
     * @memberof DeclarativeAnalyticsLayer
     */
    filterContexts?: Array<DeclarativeFilterContext>;
    /**
     * A list of metrics available in the model.
     * @type {Array<DeclarativeMetric>}
     * @memberof DeclarativeAnalyticsLayer
     */
    metrics?: Array<DeclarativeMetric>;
    /**
     * A list of visualization objects available in the model.
     * @type {Array<DeclarativeVisualizationObject>}
     * @memberof DeclarativeAnalyticsLayer
     */
    visualizationObjects?: Array<DeclarativeVisualizationObject>;
    /**
     * A list of dashboard plugins available in the model.
     * @type {Array<DeclarativeDashboardPlugin>}
     * @memberof DeclarativeAnalyticsLayer
     */
    dashboardPlugins?: Array<DeclarativeDashboardPlugin>;
}
/**
 * A dataset attribute.
 * @export
 * @interface DeclarativeAttribute
 */
export interface DeclarativeAttribute {
    /**
     * Attribute ID.
     * @type {string}
     * @memberof DeclarativeAttribute
     */
    id: string;
    /**
     * Attribute title.
     * @type {string}
     * @memberof DeclarativeAttribute
     */
    title: string;
    /**
     * Attribute description.
     * @type {string}
     * @memberof DeclarativeAttribute
     */
    description?: string;
    /**
     * An array of attribute labels.
     * @type {Array<DeclarativeLabel>}
     * @memberof DeclarativeAttribute
     */
    labels: Array<DeclarativeLabel>;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeAttribute
     */
    tags?: Array<string>;
    /**
     * Attribute sort column.
     * @type {string}
     * @memberof DeclarativeAttribute
     */
    sortColumn?: string;
    /**
     * Attribute sort direction.
     * @type {string}
     * @memberof DeclarativeAttribute
     */
    sortDirection?: DeclarativeAttributeSortDirectionEnum;
    /**
     *
     * @type {LabelIdentifier}
     * @memberof DeclarativeAttribute
     */
    defaultView?: LabelIdentifier;
}

export const DeclarativeAttributeSortDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type DeclarativeAttributeSortDirectionEnum =
    typeof DeclarativeAttributeSortDirectionEnum[keyof typeof DeclarativeAttributeSortDirectionEnum];

/**
 * A table column.
 * @export
 * @interface DeclarativeColumn
 */
export interface DeclarativeColumn {
    /**
     * Column name
     * @type {string}
     * @memberof DeclarativeColumn
     */
    name: string;
    /**
     * Column type
     * @type {string}
     * @memberof DeclarativeColumn
     */
    dataType: DeclarativeColumnDataTypeEnum;
    /**
     * Is column part of primary key?
     * @type {boolean}
     * @memberof DeclarativeColumn
     */
    isPrimaryKey?: boolean;
    /**
     * Referenced table (Foreign key)
     * @type {string}
     * @memberof DeclarativeColumn
     */
    referencedTableId?: string;
    /**
     * Referenced table (Foreign key)
     * @type {string}
     * @memberof DeclarativeColumn
     */
    referencedTableColumn?: string;
}

export const DeclarativeColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    BOOLEAN: "BOOLEAN",
} as const;

export type DeclarativeColumnDataTypeEnum =
    typeof DeclarativeColumnDataTypeEnum[keyof typeof DeclarativeColumnDataTypeEnum];

/**
 *
 * @export
 * @interface DeclarativeDashboardPlugin
 */
export interface DeclarativeDashboardPlugin {
    /**
     * Dashboard plugin object ID.
     * @type {string}
     * @memberof DeclarativeDashboardPlugin
     */
    id: string;
    /**
     * Dashboard plugin object title.
     * @type {string}
     * @memberof DeclarativeDashboardPlugin
     */
    title: string;
    /**
     * Dashboard plugin description.
     * @type {string}
     * @memberof DeclarativeDashboardPlugin
     */
    description?: string;
    /**
     * A server agnostic definition of the dashboard plugin in JSON format.
     * @type {object}
     * @memberof DeclarativeDashboardPlugin
     */
    content: object;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeDashboardPlugin
     */
    tags?: Array<string>;
}
/**
 * A data source and its properties.
 * @export
 * @interface DeclarativeDataSource
 */
export interface DeclarativeDataSource {
    /**
     * Data source ID.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    id: string;
    /**
     * Name of the data source.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    name: string;
    /**
     * Type of database.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    type: DeclarativeDataSourceTypeEnum;
    /**
     * An connection string relevant to type of database.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    url: string;
    /**
     * A scheme/database with the data.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    schema: string;
    /**
     * User with permission connect the data source/database.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    username?: string;
    /**
     * Password for the data-source user, property is never returned back.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    password?: string;
    /**
     * Token as an alternative to username and password.
     * @type {string}
     * @memberof DeclarativeDataSource
     */
    token?: string;
    /**
     * Enable caching of intermediate results.
     * @type {boolean}
     * @memberof DeclarativeDataSource
     */
    enableCaching?: boolean;
    /**
     * Path to schema, where intermediate caches are stored.
     * @type {Array<string>}
     * @memberof DeclarativeDataSource
     */
    cachePath?: Array<string>;
    /**
     *
     * @type {DeclarativeTables}
     * @memberof DeclarativeDataSource
     */
    pdm?: DeclarativeTables;
    /**
     *
     * @type {Array<DeclarativeDataSourcePermission>}
     * @memberof DeclarativeDataSource
     */
    permissions?: Array<DeclarativeDataSourcePermission>;
}

export const DeclarativeDataSourceTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
} as const;

export type DeclarativeDataSourceTypeEnum =
    typeof DeclarativeDataSourceTypeEnum[keyof typeof DeclarativeDataSourceTypeEnum];

/**
 *
 * @export
 * @interface DeclarativeDataSourcePermission
 */
export interface DeclarativeDataSourcePermission {
    /**
     * Permission name.
     * @type {string}
     * @memberof DeclarativeDataSourcePermission
     */
    name: DeclarativeDataSourcePermissionNameEnum;
    /**
     *
     * @type {AssigneeIdentifier}
     * @memberof DeclarativeDataSourcePermission
     */
    assignee: AssigneeIdentifier;
}

export const DeclarativeDataSourcePermissionNameEnum = {
    MANAGE: "MANAGE",
    USE: "USE",
} as const;

export type DeclarativeDataSourcePermissionNameEnum =
    typeof DeclarativeDataSourcePermissionNameEnum[keyof typeof DeclarativeDataSourcePermissionNameEnum];

/**
 * A data source and its properties.
 * @export
 * @interface DeclarativeDataSources
 */
export interface DeclarativeDataSources {
    /**
     *
     * @type {Array<DeclarativeDataSource>}
     * @memberof DeclarativeDataSources
     */
    dataSources: Array<DeclarativeDataSource>;
}
/**
 * A dataset defined by its properties.
 * @export
 * @interface DeclarativeDataset
 */
export interface DeclarativeDataset {
    /**
     * The Dataset ID. This ID is further used to refer to this instance of dataset.
     * @type {string}
     * @memberof DeclarativeDataset
     */
    id: string;
    /**
     * A dataset title.
     * @type {string}
     * @memberof DeclarativeDataset
     */
    title: string;
    /**
     * A dataset description.
     * @type {string}
     * @memberof DeclarativeDataset
     */
    description?: string;
    /**
     * An array of grain identifiers.
     * @type {Array<GrainIdentifier>}
     * @memberof DeclarativeDataset
     */
    grain: Array<GrainIdentifier>;
    /**
     * An array of attributes.
     * @type {Array<DeclarativeAttribute>}
     * @memberof DeclarativeDataset
     */
    attributes?: Array<DeclarativeAttribute>;
    /**
     * An array of facts.
     * @type {Array<DeclarativeFact>}
     * @memberof DeclarativeDataset
     */
    facts?: Array<DeclarativeFact>;
    /**
     * An array of references.
     * @type {Array<DeclarativeReference>}
     * @memberof DeclarativeDataset
     */
    references: Array<DeclarativeReference>;
    /**
     *
     * @type {DataSourceTableIdentifier}
     * @memberof DeclarativeDataset
     */
    dataSourceTableId?: DataSourceTableIdentifier;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeDataset
     */
    tags?: Array<string>;
}
/**
 * A date dataset.
 * @export
 * @interface DeclarativeDateDataset
 */
export interface DeclarativeDateDataset {
    /**
     * Date dataset ID.
     * @type {string}
     * @memberof DeclarativeDateDataset
     */
    id: string;
    /**
     * Date dataset title.
     * @type {string}
     * @memberof DeclarativeDateDataset
     */
    title: string;
    /**
     * Date dataset description.
     * @type {string}
     * @memberof DeclarativeDateDataset
     */
    description?: string;
    /**
     *
     * @type {GranularitiesFormatting}
     * @memberof DeclarativeDateDataset
     */
    granularitiesFormatting: GranularitiesFormatting;
    /**
     * An array of date granularities. All listed granularities will be available for date dataset.
     * @type {Array<string>}
     * @memberof DeclarativeDateDataset
     */
    granularities: Array<DeclarativeDateDatasetGranularitiesEnum>;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeDateDataset
     */
    tags?: Array<string>;
}

export const DeclarativeDateDatasetGranularitiesEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type DeclarativeDateDatasetGranularitiesEnum =
    typeof DeclarativeDateDatasetGranularitiesEnum[keyof typeof DeclarativeDateDatasetGranularitiesEnum];

/**
 * A dataset fact.
 * @export
 * @interface DeclarativeFact
 */
export interface DeclarativeFact {
    /**
     * Fact ID.
     * @type {string}
     * @memberof DeclarativeFact
     */
    id: string;
    /**
     * Fact title.
     * @type {string}
     * @memberof DeclarativeFact
     */
    title: string;
    /**
     * Fact description.
     * @type {string}
     * @memberof DeclarativeFact
     */
    description?: string;
    /**
     * A name of the source column in the table.
     * @type {string}
     * @memberof DeclarativeFact
     */
    sourceColumn: string;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeFact
     */
    tags?: Array<string>;
}
/**
 *
 * @export
 * @interface DeclarativeFilterContext
 */
export interface DeclarativeFilterContext {
    /**
     * Filter Context ID.
     * @type {string}
     * @memberof DeclarativeFilterContext
     */
    id: string;
    /**
     * Filter Context title.
     * @type {string}
     * @memberof DeclarativeFilterContext
     */
    title: string;
    /**
     * Filter Context description.
     * @type {string}
     * @memberof DeclarativeFilterContext
     */
    description?: string;
    /**
     * A server agnostic definition of the dashboard plugin in JSON format.
     * @type {object}
     * @memberof DeclarativeFilterContext
     */
    content: object;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeFilterContext
     */
    tags?: Array<string>;
}
/**
 * A attribute label.
 * @export
 * @interface DeclarativeLabel
 */
export interface DeclarativeLabel {
    /**
     * Label ID.
     * @type {string}
     * @memberof DeclarativeLabel
     */
    id: string;
    /**
     * Label title.
     * @type {string}
     * @memberof DeclarativeLabel
     */
    title: string;
    /**
     * Label description.
     * @type {string}
     * @memberof DeclarativeLabel
     */
    description?: string;
    /**
     * A flag indicating whether the label should be treated as a primary one.
     * @type {boolean}
     * @memberof DeclarativeLabel
     */
    primary: boolean;
    /**
     * A name of the source column in the table.
     * @type {string}
     * @memberof DeclarativeLabel
     */
    sourceColumn: string;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeLabel
     */
    tags?: Array<string>;
    /**
     * Specific type of label
     * @type {string}
     * @memberof DeclarativeLabel
     */
    valueType?: DeclarativeLabelValueTypeEnum;
}

export const DeclarativeLabelValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
} as const;

export type DeclarativeLabelValueTypeEnum =
    typeof DeclarativeLabelValueTypeEnum[keyof typeof DeclarativeLabelValueTypeEnum];

/**
 * A logical data model (LDM) representation.
 * @export
 * @interface DeclarativeLdm
 */
export interface DeclarativeLdm {
    /**
     * An array containing datasets.
     * @type {Array<DeclarativeDataset>}
     * @memberof DeclarativeLdm
     */
    datasets?: Array<DeclarativeDataset>;
    /**
     * An array containing date-related datasets.
     * @type {Array<DeclarativeDateDataset>}
     * @memberof DeclarativeLdm
     */
    dateInstances?: Array<DeclarativeDateDataset>;
}
/**
 *
 * @export
 * @interface DeclarativeMetric
 */
export interface DeclarativeMetric {
    /**
     * Metric ID.
     * @type {string}
     * @memberof DeclarativeMetric
     */
    id: string;
    /**
     * Metric title.
     * @type {string}
     * @memberof DeclarativeMetric
     */
    title: string;
    /**
     * Metric description.
     * @type {string}
     * @memberof DeclarativeMetric
     */
    description?: string;
    /**
     * A server agnostic definition of the dashboard plugin in JSON format.
     * @type {object}
     * @memberof DeclarativeMetric
     */
    content: object;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeMetric
     */
    tags?: Array<string>;
}
/**
 * A data model structured as a set of its attributes.
 * @export
 * @interface DeclarativeModel
 */
export interface DeclarativeModel {
    /**
     *
     * @type {DeclarativeLdm}
     * @memberof DeclarativeModel
     */
    ldm?: DeclarativeLdm;
}
/**
 * Complete definition of an organization in a declarative form.
 * @export
 * @interface DeclarativeOrganization
 */
export interface DeclarativeOrganization {
    /**
     *
     * @type {DeclarativeOrganizationInfo}
     * @memberof DeclarativeOrganization
     */
    organization: DeclarativeOrganizationInfo;
    /**
     *
     * @type {Array<DeclarativeUser>}
     * @memberof DeclarativeOrganization
     */
    users?: Array<DeclarativeUser>;
    /**
     *
     * @type {Array<DeclarativeUserGroup>}
     * @memberof DeclarativeOrganization
     */
    userGroups?: Array<DeclarativeUserGroup>;
    /**
     *
     * @type {Array<DeclarativeDataSource>}
     * @memberof DeclarativeOrganization
     */
    dataSources?: Array<DeclarativeDataSource>;
    /**
     *
     * @type {Array<DeclarativeWorkspace>}
     * @memberof DeclarativeOrganization
     */
    workspaces?: Array<DeclarativeWorkspace>;
    /**
     *
     * @type {Array<DeclarativeWorkspaceDataFilter>}
     * @memberof DeclarativeOrganization
     */
    workspaceDataFilters?: Array<DeclarativeWorkspaceDataFilter>;
}
/**
 * Information available about an organization.
 * @export
 * @interface DeclarativeOrganizationInfo
 */
export interface DeclarativeOrganizationInfo {
    /**
     * Identifier of the organization.
     * @type {string}
     * @memberof DeclarativeOrganizationInfo
     */
    id: string;
    /**
     * Formal name of the organization.
     * @type {string}
     * @memberof DeclarativeOrganizationInfo
     */
    name: string;
    /**
     * Formal hostname used in deployment.
     * @type {string}
     * @memberof DeclarativeOrganizationInfo
     */
    hostname: string;
    /**
     * URI of the authentication provider.
     * @type {string}
     * @memberof DeclarativeOrganizationInfo
     */
    oauthIssuerLocation?: string;
    /**
     * Identifier of the authentication provider
     * @type {string}
     * @memberof DeclarativeOrganizationInfo
     */
    oauthClientId?: string;
    /**
     * Communication secret of the authentication provider (never returned back).
     * @type {string}
     * @memberof DeclarativeOrganizationInfo
     */
    oauthClientSecret?: string;
    /**
     *
     * @type {Array<DeclarativeOrganizationPermission>}
     * @memberof DeclarativeOrganizationInfo
     */
    permissions: Array<DeclarativeOrganizationPermission>;
}
/**
 * Definition of a permission assigned to a user/user-group.
 * @export
 * @interface DeclarativeOrganizationPermission
 */
export interface DeclarativeOrganizationPermission {
    /**
     * Permission name.
     * @type {string}
     * @memberof DeclarativeOrganizationPermission
     */
    name: DeclarativeOrganizationPermissionNameEnum;
    /**
     *
     * @type {AssigneeIdentifier}
     * @memberof DeclarativeOrganizationPermission
     */
    assignee: AssigneeIdentifier;
}

export const DeclarativeOrganizationPermissionNameEnum = {
    MANAGE: "MANAGE",
} as const;

export type DeclarativeOrganizationPermissionNameEnum =
    typeof DeclarativeOrganizationPermissionNameEnum[keyof typeof DeclarativeOrganizationPermissionNameEnum];

/**
 * A physical data model (PDM) representation for single data source.
 * @export
 * @interface DeclarativePdm
 */
export interface DeclarativePdm {
    /**
     *
     * @type {DeclarativeTables}
     * @memberof DeclarativePdm
     */
    pdm: DeclarativeTables;
}
/**
 * A dataset reference.
 * @export
 * @interface DeclarativeReference
 */
export interface DeclarativeReference {
    /**
     *
     * @type {ReferenceIdentifier}
     * @memberof DeclarativeReference
     */
    identifier: ReferenceIdentifier;
    /**
     * The multi-value flag enables many-to-many cardinality for references.
     * @type {boolean}
     * @memberof DeclarativeReference
     */
    multivalue: boolean;
    /**
     * An array of source column names for a given reference.
     * @type {Array<string>}
     * @memberof DeclarativeReference
     */
    sourceColumns: Array<string>;
}
/**
 *
 * @export
 * @interface DeclarativeSingleWorkspacePermission
 */
export interface DeclarativeSingleWorkspacePermission {
    /**
     * Permission name.
     * @type {string}
     * @memberof DeclarativeSingleWorkspacePermission
     */
    name: DeclarativeSingleWorkspacePermissionNameEnum;
    /**
     *
     * @type {AssigneeIdentifier}
     * @memberof DeclarativeSingleWorkspacePermission
     */
    assignee: AssigneeIdentifier;
}

export const DeclarativeSingleWorkspacePermissionNameEnum = {
    MANAGE: "MANAGE",
    ANALYZE: "ANALYZE",
    VIEW: "VIEW",
} as const;

export type DeclarativeSingleWorkspacePermissionNameEnum =
    typeof DeclarativeSingleWorkspacePermissionNameEnum[keyof typeof DeclarativeSingleWorkspacePermissionNameEnum];

/**
 * A database table.
 * @export
 * @interface DeclarativeTable
 */
export interface DeclarativeTable {
    /**
     * Table id.
     * @type {string}
     * @memberof DeclarativeTable
     */
    id: string;
    /**
     * Path to table.
     * @type {Array<string>}
     * @memberof DeclarativeTable
     */
    path: Array<string>;
    /**
     * Table type: TABLE or VIEW.
     * @type {string}
     * @memberof DeclarativeTable
     */
    type: string;
    /**
     * Table or view name prefix used in scan. Will be stripped when generating LDM.
     * @type {string}
     * @memberof DeclarativeTable
     */
    namePrefix?: string;
    /**
     * An array of physical columns
     * @type {Array<DeclarativeColumn>}
     * @memberof DeclarativeTable
     */
    columns: Array<DeclarativeColumn>;
}
/**
 * A physical data model (PDM) tables.
 * @export
 * @interface DeclarativeTables
 */
export interface DeclarativeTables {
    /**
     * An array of physical database tables.
     * @type {Array<DeclarativeTable>}
     * @memberof DeclarativeTables
     */
    tables: Array<DeclarativeTable>;
}
/**
 * A user and its properties
 * @export
 * @interface DeclarativeUser
 */
export interface DeclarativeUser {
    /**
     * User identifier.
     * @type {string}
     * @memberof DeclarativeUser
     */
    id: string;
    /**
     * User identification in the authentication manager.
     * @type {string}
     * @memberof DeclarativeUser
     */
    authId?: string;
    /**
     *
     * @type {Array<UserGroupIdentifier>}
     * @memberof DeclarativeUser
     */
    userGroups?: Array<UserGroupIdentifier>;
}
/**
 * A user-group and its properties
 * @export
 * @interface DeclarativeUserGroup
 */
export interface DeclarativeUserGroup {
    /**
     * UserGroup identifier.
     * @type {string}
     * @memberof DeclarativeUserGroup
     */
    id: string;
    /**
     *
     * @type {Array<UserGroupIdentifier>}
     * @memberof DeclarativeUserGroup
     */
    parents?: Array<UserGroupIdentifier>;
}
/**
 * Declarative form of userGroups and its properties.
 * @export
 * @interface DeclarativeUserGroups
 */
export interface DeclarativeUserGroups {
    /**
     *
     * @type {Array<DeclarativeUserGroup>}
     * @memberof DeclarativeUserGroups
     */
    userGroups: Array<DeclarativeUserGroup>;
}
/**
 * Declarative form of users and its properties.
 * @export
 * @interface DeclarativeUsers
 */
export interface DeclarativeUsers {
    /**
     *
     * @type {Array<DeclarativeUser>}
     * @memberof DeclarativeUsers
     */
    users: Array<DeclarativeUser>;
}
/**
 * Declarative form of both users and user groups and theirs properties.
 * @export
 * @interface DeclarativeUsersUserGroups
 */
export interface DeclarativeUsersUserGroups {
    /**
     *
     * @type {Array<DeclarativeUser>}
     * @memberof DeclarativeUsersUserGroups
     */
    users: Array<DeclarativeUser>;
    /**
     *
     * @type {Array<DeclarativeUserGroup>}
     * @memberof DeclarativeUsersUserGroups
     */
    userGroups: Array<DeclarativeUserGroup>;
}
/**
 *
 * @export
 * @interface DeclarativeVisualizationObject
 */
export interface DeclarativeVisualizationObject {
    /**
     * Visualization object ID.
     * @type {string}
     * @memberof DeclarativeVisualizationObject
     */
    id: string;
    /**
     * Visualization object title.
     * @type {string}
     * @memberof DeclarativeVisualizationObject
     */
    title: string;
    /**
     * Visualization object description.
     * @type {string}
     * @memberof DeclarativeVisualizationObject
     */
    description?: string;
    /**
     * A server agnostic definition of the dashboard plugin in JSON format.
     * @type {object}
     * @memberof DeclarativeVisualizationObject
     */
    content: object;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof DeclarativeVisualizationObject
     */
    tags?: Array<string>;
}
/**
 * A declarative form of a particular workspace.
 * @export
 * @interface DeclarativeWorkspace
 */
export interface DeclarativeWorkspace {
    /**
     * Identifier of a workspace
     * @type {string}
     * @memberof DeclarativeWorkspace
     */
    id: string;
    /**
     * Name of a workspace to view.
     * @type {string}
     * @memberof DeclarativeWorkspace
     */
    name: string;
    /**
     *
     * @type {DeclarativeWorkspaceModel}
     * @memberof DeclarativeWorkspace
     */
    model?: DeclarativeWorkspaceModel;
    /**
     *
     * @type {WorkspaceIdentifier}
     * @memberof DeclarativeWorkspace
     */
    parent?: WorkspaceIdentifier;
    /**
     *
     * @type {Array<DeclarativeSingleWorkspacePermission>}
     * @memberof DeclarativeWorkspace
     */
    permissions?: Array<DeclarativeSingleWorkspacePermission>;
    /**
     *
     * @type {Array<DeclarativeWorkspaceHierarchyPermission>}
     * @memberof DeclarativeWorkspace
     */
    hierarchyPermissions?: Array<DeclarativeWorkspaceHierarchyPermission>;
}
/**
 * Workspace Data Filters serving the filtering of what data users can see in workspaces.
 * @export
 * @interface DeclarativeWorkspaceDataFilter
 */
export interface DeclarativeWorkspaceDataFilter {
    /**
     * Workspace Data Filters ID. This ID is further used to refer to this instance.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilter
     */
    id: string;
    /**
     * Workspace Data Filters title.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilter
     */
    title: string;
    /**
     * Workspace Data Filters description.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilter
     */
    description?: string;
    /**
     * Workspace Data Filters column name. Data are filtered using this physical column.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilter
     */
    columnName: string;
    /**
     * Filter settings specifying values of filters valid for the workspace.
     * @type {Array<DeclarativeWorkspaceDataFilterSetting>}
     * @memberof DeclarativeWorkspaceDataFilter
     */
    workspaceDataFilterSettings: Array<DeclarativeWorkspaceDataFilterSetting>;
    /**
     *
     * @type {WorkspaceIdentifier}
     * @memberof DeclarativeWorkspaceDataFilter
     */
    workspace?: WorkspaceIdentifier;
}
/**
 * Workspace Data Filters serving the filtering of what data users can see in workspaces.
 * @export
 * @interface DeclarativeWorkspaceDataFilterSetting
 */
export interface DeclarativeWorkspaceDataFilterSetting {
    /**
     * Workspace Data Filters ID. This ID is further used to refer to this instance.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilterSetting
     */
    id: string;
    /**
     * Workspace Data Filters setting title.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilterSetting
     */
    title: string;
    /**
     * Workspace Data Filters setting description.
     * @type {string}
     * @memberof DeclarativeWorkspaceDataFilterSetting
     */
    description?: string;
    /**
     * Only those rows are returned, where columnName from filter matches those values.
     * @type {Array<string>}
     * @memberof DeclarativeWorkspaceDataFilterSetting
     */
    filterValues: Array<string>;
    /**
     *
     * @type {WorkspaceIdentifier}
     * @memberof DeclarativeWorkspaceDataFilterSetting
     */
    workspace: WorkspaceIdentifier;
}
/**
 * Declarative form of data filters.
 * @export
 * @interface DeclarativeWorkspaceDataFilters
 */
export interface DeclarativeWorkspaceDataFilters {
    /**
     *
     * @type {Array<DeclarativeWorkspaceDataFilter>}
     * @memberof DeclarativeWorkspaceDataFilters
     */
    workspaceDataFilters: Array<DeclarativeWorkspaceDataFilter>;
}
/**
 *
 * @export
 * @interface DeclarativeWorkspaceHierarchyPermission
 */
export interface DeclarativeWorkspaceHierarchyPermission {
    /**
     * Permission name.
     * @type {string}
     * @memberof DeclarativeWorkspaceHierarchyPermission
     */
    name: DeclarativeWorkspaceHierarchyPermissionNameEnum;
    /**
     *
     * @type {AssigneeIdentifier}
     * @memberof DeclarativeWorkspaceHierarchyPermission
     */
    assignee: AssigneeIdentifier;
}

export const DeclarativeWorkspaceHierarchyPermissionNameEnum = {
    MANAGE: "MANAGE",
    ANALYZE: "ANALYZE",
    VIEW: "VIEW",
} as const;

export type DeclarativeWorkspaceHierarchyPermissionNameEnum =
    typeof DeclarativeWorkspaceHierarchyPermissionNameEnum[keyof typeof DeclarativeWorkspaceHierarchyPermissionNameEnum];

/**
 * A declarative form of a model and analytics for a workspace.
 * @export
 * @interface DeclarativeWorkspaceModel
 */
export interface DeclarativeWorkspaceModel {
    /**
     *
     * @type {DeclarativeLdm}
     * @memberof DeclarativeWorkspaceModel
     */
    ldm?: DeclarativeLdm;
    /**
     *
     * @type {DeclarativeAnalyticsLayer}
     * @memberof DeclarativeWorkspaceModel
     */
    analytics?: DeclarativeAnalyticsLayer;
}
/**
 * Definition of permissions associated with a workspace.
 * @export
 * @interface DeclarativeWorkspacePermissions
 */
export interface DeclarativeWorkspacePermissions {
    /**
     *
     * @type {Array<DeclarativeSingleWorkspacePermission>}
     * @memberof DeclarativeWorkspacePermissions
     */
    permissions?: Array<DeclarativeSingleWorkspacePermission>;
    /**
     *
     * @type {Array<DeclarativeWorkspaceHierarchyPermission>}
     * @memberof DeclarativeWorkspacePermissions
     */
    hierarchyPermissions?: Array<DeclarativeWorkspaceHierarchyPermission>;
}
/**
 * A declarative form of a all workspace layout.
 * @export
 * @interface DeclarativeWorkspaces
 */
export interface DeclarativeWorkspaces {
    /**
     *
     * @type {Array<DeclarativeWorkspace>}
     * @memberof DeclarativeWorkspaces
     */
    workspaces: Array<DeclarativeWorkspace>;
    /**
     *
     * @type {Array<DeclarativeWorkspaceDataFilter>}
     * @memberof DeclarativeWorkspaces
     */
    workspaceDataFilters: Array<DeclarativeWorkspaceDataFilter>;
}
/**
 * A request containing all information needed for generation of logical model.
 * @export
 * @interface GenerateLdmRequest
 */
export interface GenerateLdmRequest {
    /**
     * A flag dictating how the attribute, fact and label ids are generated. By default their ids are derived only from the column name, unless there would be a conflict (e.g. category coming from two different tables). In that case a long id format of `<table>.<column>` is used. If the flag is set to true, then all ids will be generated in the long form.
     * @type {boolean}
     * @memberof GenerateLdmRequest
     */
    generateLongIds?: boolean;
    /**
     * A separator between prefixes and the names. Default is \"__\".
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    separator: string;
    /**
     * Tables starting with this prefix will be included. The prefix is then followed by the value of `separator` parameter. Given the table prefix is `out_table` and separator is `__`, the table with name like `out_table__customers` will be scanned.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    tablePrefix?: string;
    /**
     * Views starting with this prefix will be included. The prefix is then followed by the value of `separator` parameter. Given the view prefix is `out_view` and separator is `__`, the table with name like `out_view__us_customers` will be scanned.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    viewPrefix?: string;
    /**
     * Columns starting with this prefix will be considered as primary labels. The prefix is then followed by the value of `separator` parameter. Given the primary label prefix is `pl` and separator is `__`, the columns with name like `pl__country_id` will be considered as primary labels.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    primaryLabelPrefix?: string;
    /**
     * Columns starting with this prefix will be considered as secondary labels. The prefix is then followed by the value of `separator` parameter. Given the secondary label prefix is `sl` and separator is `__`, the columns with name like `sl__country_id_country_name` will be considered as secondary labels.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    secondaryLabelPrefix?: string;
    /**
     * Columns starting with this prefix will be considered as facts. The prefix is then followed by the value of `separator` parameter. Given the fact prefix is `f` and separator is `__`, the columns with name like `f__sold` will be considered as facts.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    factPrefix?: string;
    /**
     * Option to control date granularities for date datasets. Empty value enables common date granularities (DAY, WEEK, MONTH, QUARTER, YEAR). Default value is `all` which enables all available date granularities, including time granularities (like hours, minutes).
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    dateGranularities?: string;
    /**
     * Columns starting with this prefix will be considered as grains. The prefix is then followed by the value of `separator` parameter. Given the grain prefix is `g` and separator is `__`, the columns with name like `g__name` will be considered as grains.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    grainPrefix?: string;
    /**
     * Columns starting with this prefix will be considered as references. The prefix is then followed by the value of `separator` parameter. Given the reference prefix is `r` and separator is `__`, the columns with name like `r__customer_name` will be considered as references.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    referencePrefix?: string;
    /**
     * Columns starting with this prefix will be considered as grain references. The prefix is then followed by the value of `separator` parameter. Given the reference prefix is `gr` and separator is `__`, the columns with name like `gr__customer_name` will be considered as grain references.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    grainReferencePrefix?: string;
    /**
     * Columns starting with this prefix will be considered as denormalization references. The prefix is then followed by the value of `separator` parameter. Given the denormalization reference prefix is `dr` and separator is `__`, the columns with name like `dr__customer_name` will be considered as denormalization references.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    denormPrefix?: string;
    /**
     * Column serving as workspace data filter. No labels are auto generated for such columns.
     * @type {string}
     * @memberof GenerateLdmRequest
     */
    wdfPrefix?: string;
}
/**
 * A grain identifier.
 * @export
 * @interface GrainIdentifier
 */
export interface GrainIdentifier {
    /**
     * Grain ID.
     * @type {string}
     * @memberof GrainIdentifier
     */
    id: string;
    /**
     * A type of the grain.
     * @type {string}
     * @memberof GrainIdentifier
     */
    type: GrainIdentifierTypeEnum;
}

export const GrainIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    DATASET: "dataset",
} as const;

export type GrainIdentifierTypeEnum = typeof GrainIdentifierTypeEnum[keyof typeof GrainIdentifierTypeEnum];

/**
 * A date dataset granularities title formatting rules.
 * @export
 * @interface GranularitiesFormatting
 */
export interface GranularitiesFormatting {
    /**
     * Title base is used as a token in title pattern. If left empty, it is replaced by date dataset title.
     * @type {string}
     * @memberof GranularitiesFormatting
     */
    titleBase: string;
    /**
     * This pattern is used to generate the title of attributes and labels that result from the granularities. There are two tokens available:  * `%titleBase` - represents shared part by all titles, or title of Date Dataset if left empty * `%granularityTitle` - represents `DateGranularity` built-in title
     * @type {string}
     * @memberof GranularitiesFormatting
     */
    titlePattern: string;
}
/**
 * JSON:API representation of analyticalDashboard entity.
 * @export
 * @interface JsonApiAnalyticalDashboardIn
 */
export interface JsonApiAnalyticalDashboardIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardIn
     */
    type: JsonApiAnalyticalDashboardInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardIn
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiAnalyticalDashboardIn
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
}

export const JsonApiAnalyticalDashboardInTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type JsonApiAnalyticalDashboardInTypeEnum =
    typeof JsonApiAnalyticalDashboardInTypeEnum[keyof typeof JsonApiAnalyticalDashboardInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardInDocument
 */
export interface JsonApiAnalyticalDashboardInDocument {
    /**
     *
     * @type {JsonApiAnalyticalDashboardIn}
     * @memberof JsonApiAnalyticalDashboardInDocument
     */
    data: JsonApiAnalyticalDashboardIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiAnalyticalDashboardLinkage
 */
export interface JsonApiAnalyticalDashboardLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardLinkage
     */
    type: JsonApiAnalyticalDashboardLinkageTypeEnum;
}

export const JsonApiAnalyticalDashboardLinkageTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type JsonApiAnalyticalDashboardLinkageTypeEnum =
    typeof JsonApiAnalyticalDashboardLinkageTypeEnum[keyof typeof JsonApiAnalyticalDashboardLinkageTypeEnum];

/**
 * JSON:API representation of analyticalDashboard entity.
 * @export
 * @interface JsonApiAnalyticalDashboardOut
 */
export interface JsonApiAnalyticalDashboardOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardOut
     */
    type: JsonApiAnalyticalDashboardOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardOut
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiAnalyticalDashboardOut
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationships}
     * @memberof JsonApiAnalyticalDashboardOut
     */
    relationships?: JsonApiAnalyticalDashboardOutRelationships;
}

export const JsonApiAnalyticalDashboardOutTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type JsonApiAnalyticalDashboardOutTypeEnum =
    typeof JsonApiAnalyticalDashboardOutTypeEnum[keyof typeof JsonApiAnalyticalDashboardOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutDocument
 */
export interface JsonApiAnalyticalDashboardOutDocument {
    /**
     *
     * @type {JsonApiAnalyticalDashboardOut}
     * @memberof JsonApiAnalyticalDashboardOutDocument
     */
    data: JsonApiAnalyticalDashboardOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiAnalyticalDashboardOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiAnalyticalDashboardOutIncludes>}
     * @memberof JsonApiAnalyticalDashboardOutDocument
     */
    included?: Array<JsonApiAnalyticalDashboardOutIncludes>;
}
/**
 * @type JsonApiAnalyticalDashboardOutIncludes
 * @export
 */
export type JsonApiAnalyticalDashboardOutIncludes =
    | JsonApiAnalyticalDashboardOutWithLinks
    | JsonApiDashboardPluginOutWithLinks
    | JsonApiDatasetOutWithLinks
    | JsonApiFilterContextOutWithLinks
    | JsonApiLabelOutWithLinks
    | JsonApiMetricOutWithLinks
    | JsonApiVisualizationObjectOutWithLinks;

/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiAnalyticalDashboardOutList
 */
export interface JsonApiAnalyticalDashboardOutList {
    /**
     *
     * @type {Array<JsonApiAnalyticalDashboardOutWithLinks>}
     * @memberof JsonApiAnalyticalDashboardOutList
     */
    data: Array<JsonApiAnalyticalDashboardOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiAnalyticalDashboardOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiAnalyticalDashboardOutIncludes>}
     * @memberof JsonApiAnalyticalDashboardOutList
     */
    included?: Array<JsonApiAnalyticalDashboardOutIncludes>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationships
 */
export interface JsonApiAnalyticalDashboardOutRelationships {
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsVisualizationObjects}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    visualizationObjects?: JsonApiAnalyticalDashboardOutRelationshipsVisualizationObjects;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsAnalyticalDashboards}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    analyticalDashboards?: JsonApiAnalyticalDashboardOutRelationshipsAnalyticalDashboards;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsLabels}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    labels?: JsonApiAnalyticalDashboardOutRelationshipsLabels;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsMetrics}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    metrics?: JsonApiAnalyticalDashboardOutRelationshipsMetrics;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsDatasets}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    datasets?: JsonApiAnalyticalDashboardOutRelationshipsDatasets;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsFilterContexts}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    filterContexts?: JsonApiAnalyticalDashboardOutRelationshipsFilterContexts;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsDashboardPlugins}
     * @memberof JsonApiAnalyticalDashboardOutRelationships
     */
    dashboardPlugins?: JsonApiAnalyticalDashboardOutRelationshipsDashboardPlugins;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsAnalyticalDashboards
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsAnalyticalDashboards {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiAnalyticalDashboardLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsAnalyticalDashboards
     */
    data: Array<JsonApiAnalyticalDashboardLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsDashboardPlugins
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsDashboardPlugins {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiDashboardPluginLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsDashboardPlugins
     */
    data: Array<JsonApiDashboardPluginLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsDatasets
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsDatasets {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiDatasetLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsDatasets
     */
    data: Array<JsonApiDatasetLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsFilterContexts
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsFilterContexts {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiFilterContextLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsFilterContexts
     */
    data: Array<JsonApiFilterContextLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsLabels
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsLabels {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiLabelLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsLabels
     */
    data: Array<JsonApiLabelLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsMetrics
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsMetrics {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiMetricLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsMetrics
     */
    data: Array<JsonApiMetricLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutRelationshipsVisualizationObjects
 */
export interface JsonApiAnalyticalDashboardOutRelationshipsVisualizationObjects {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiVisualizationObjectLinkage>}
     * @memberof JsonApiAnalyticalDashboardOutRelationshipsVisualizationObjects
     */
    data: Array<JsonApiVisualizationObjectLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardOutWithLinks
 */
export interface JsonApiAnalyticalDashboardOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardOutWithLinks
     */
    type: JsonApiAnalyticalDashboardOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiAnalyticalDashboardOutWithLinks
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationships}
     * @memberof JsonApiAnalyticalDashboardOutWithLinks
     */
    relationships?: JsonApiAnalyticalDashboardOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiAnalyticalDashboardOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiAnalyticalDashboardOutWithLinksTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type JsonApiAnalyticalDashboardOutWithLinksTypeEnum =
    typeof JsonApiAnalyticalDashboardOutWithLinksTypeEnum[keyof typeof JsonApiAnalyticalDashboardOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching analyticalDashboard entity.
 * @export
 * @interface JsonApiAnalyticalDashboardPatch
 */
export interface JsonApiAnalyticalDashboardPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardPatch
     */
    type: JsonApiAnalyticalDashboardPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiAnalyticalDashboardPatch
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
}

export const JsonApiAnalyticalDashboardPatchTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type JsonApiAnalyticalDashboardPatchTypeEnum =
    typeof JsonApiAnalyticalDashboardPatchTypeEnum[keyof typeof JsonApiAnalyticalDashboardPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardPatchAttributes
 */
export interface JsonApiAnalyticalDashboardPatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardPatchAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiAnalyticalDashboardPatchAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiAnalyticalDashboardPatchAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiAnalyticalDashboardPatchAttributes
     */
    areRelationsValid?: boolean;
    /**
     * Free-form JSON content.
     * @type {object}
     * @memberof JsonApiAnalyticalDashboardPatchAttributes
     */
    content?: object;
}
/**
 *
 * @export
 * @interface JsonApiAnalyticalDashboardPatchDocument
 */
export interface JsonApiAnalyticalDashboardPatchDocument {
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatch}
     * @memberof JsonApiAnalyticalDashboardPatchDocument
     */
    data: JsonApiAnalyticalDashboardPatch;
}
/**
 * JSON:API representation of apiToken entity.
 * @export
 * @interface JsonApiApiTokenIn
 */
export interface JsonApiApiTokenIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiApiTokenIn
     */
    type: JsonApiApiTokenInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiApiTokenIn
     */
    id: string;
}

export const JsonApiApiTokenInTypeEnum = {
    API_TOKEN: "apiToken",
} as const;

export type JsonApiApiTokenInTypeEnum =
    typeof JsonApiApiTokenInTypeEnum[keyof typeof JsonApiApiTokenInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiApiTokenInDocument
 */
export interface JsonApiApiTokenInDocument {
    /**
     *
     * @type {JsonApiApiTokenIn}
     * @memberof JsonApiApiTokenInDocument
     */
    data: JsonApiApiTokenIn;
}
/**
 * JSON:API representation of apiToken entity.
 * @export
 * @interface JsonApiApiTokenOut
 */
export interface JsonApiApiTokenOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiApiTokenOut
     */
    type: JsonApiApiTokenOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiApiTokenOut
     */
    id: string;
    /**
     *
     * @type {JsonApiApiTokenOutAttributes}
     * @memberof JsonApiApiTokenOut
     */
    attributes?: JsonApiApiTokenOutAttributes;
}

export const JsonApiApiTokenOutTypeEnum = {
    API_TOKEN: "apiToken",
} as const;

export type JsonApiApiTokenOutTypeEnum =
    typeof JsonApiApiTokenOutTypeEnum[keyof typeof JsonApiApiTokenOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiApiTokenOutAttributes
 */
export interface JsonApiApiTokenOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiApiTokenOutAttributes
     */
    bearerToken?: string;
}
/**
 *
 * @export
 * @interface JsonApiApiTokenOutDocument
 */
export interface JsonApiApiTokenOutDocument {
    /**
     *
     * @type {JsonApiApiTokenOut}
     * @memberof JsonApiApiTokenOutDocument
     */
    data: JsonApiApiTokenOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiApiTokenOutDocument
     */
    links?: ObjectLinks;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiApiTokenOutList
 */
export interface JsonApiApiTokenOutList {
    /**
     *
     * @type {Array<JsonApiApiTokenOutWithLinks>}
     * @memberof JsonApiApiTokenOutList
     */
    data: Array<JsonApiApiTokenOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiApiTokenOutList
     */
    links?: ListLinks;
}
/**
 *
 * @export
 * @interface JsonApiApiTokenOutWithLinks
 */
export interface JsonApiApiTokenOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiApiTokenOutWithLinks
     */
    type: JsonApiApiTokenOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiApiTokenOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiApiTokenOutAttributes}
     * @memberof JsonApiApiTokenOutWithLinks
     */
    attributes?: JsonApiApiTokenOutAttributes;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiApiTokenOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiApiTokenOutWithLinksTypeEnum = {
    API_TOKEN: "apiToken",
} as const;

export type JsonApiApiTokenOutWithLinksTypeEnum =
    typeof JsonApiApiTokenOutWithLinksTypeEnum[keyof typeof JsonApiApiTokenOutWithLinksTypeEnum];

/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiAttributeLinkage
 */
export interface JsonApiAttributeLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeLinkage
     */
    type: JsonApiAttributeLinkageTypeEnum;
}

export const JsonApiAttributeLinkageTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type JsonApiAttributeLinkageTypeEnum =
    typeof JsonApiAttributeLinkageTypeEnum[keyof typeof JsonApiAttributeLinkageTypeEnum];

/**
 * JSON:API representation of attribute entity.
 * @export
 * @interface JsonApiAttributeOut
 */
export interface JsonApiAttributeOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiAttributeOut
     */
    type: JsonApiAttributeOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiAttributeOut
     */
    id: string;
    /**
     *
     * @type {JsonApiAttributeOutAttributes}
     * @memberof JsonApiAttributeOut
     */
    attributes?: JsonApiAttributeOutAttributes;
    /**
     *
     * @type {JsonApiAttributeOutRelationships}
     * @memberof JsonApiAttributeOut
     */
    relationships?: JsonApiAttributeOutRelationships;
}

export const JsonApiAttributeOutTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type JsonApiAttributeOutTypeEnum =
    typeof JsonApiAttributeOutTypeEnum[keyof typeof JsonApiAttributeOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiAttributeOutAttributes
 */
export interface JsonApiAttributeOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeOutAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeOutAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiAttributeOutAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeOutAttributes
     */
    granularity?: JsonApiAttributeOutAttributesGranularityEnum;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiAttributeOutAttributes
     */
    areRelationsValid?: boolean;
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeOutAttributes
     */
    sortColumn?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiAttributeOutAttributes
     */
    sortDirection?: JsonApiAttributeOutAttributesSortDirectionEnum;
}

export const JsonApiAttributeOutAttributesGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type JsonApiAttributeOutAttributesGranularityEnum =
    typeof JsonApiAttributeOutAttributesGranularityEnum[keyof typeof JsonApiAttributeOutAttributesGranularityEnum];
export const JsonApiAttributeOutAttributesSortDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type JsonApiAttributeOutAttributesSortDirectionEnum =
    typeof JsonApiAttributeOutAttributesSortDirectionEnum[keyof typeof JsonApiAttributeOutAttributesSortDirectionEnum];

/**
 *
 * @export
 * @interface JsonApiAttributeOutDocument
 */
export interface JsonApiAttributeOutDocument {
    /**
     *
     * @type {JsonApiAttributeOut}
     * @memberof JsonApiAttributeOutDocument
     */
    data: JsonApiAttributeOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiAttributeOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiAttributeOutIncludes>}
     * @memberof JsonApiAttributeOutDocument
     */
    included?: Array<JsonApiAttributeOutIncludes>;
}
/**
 * @type JsonApiAttributeOutIncludes
 * @export
 */
export type JsonApiAttributeOutIncludes = JsonApiDatasetOutWithLinks | JsonApiLabelOutWithLinks;

/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiAttributeOutList
 */
export interface JsonApiAttributeOutList {
    /**
     *
     * @type {Array<JsonApiAttributeOutWithLinks>}
     * @memberof JsonApiAttributeOutList
     */
    data: Array<JsonApiAttributeOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiAttributeOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiAttributeOutIncludes>}
     * @memberof JsonApiAttributeOutList
     */
    included?: Array<JsonApiAttributeOutIncludes>;
}
/**
 *
 * @export
 * @interface JsonApiAttributeOutRelationships
 */
export interface JsonApiAttributeOutRelationships {
    /**
     *
     * @type {JsonApiAttributeOutRelationshipsDataset}
     * @memberof JsonApiAttributeOutRelationships
     */
    dataset?: JsonApiAttributeOutRelationshipsDataset;
    /**
     *
     * @type {JsonApiAttributeOutRelationshipsDefaultView}
     * @memberof JsonApiAttributeOutRelationships
     */
    defaultView?: JsonApiAttributeOutRelationshipsDefaultView;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsLabels}
     * @memberof JsonApiAttributeOutRelationships
     */
    labels?: JsonApiAnalyticalDashboardOutRelationshipsLabels;
}
/**
 *
 * @export
 * @interface JsonApiAttributeOutRelationshipsDataset
 */
export interface JsonApiAttributeOutRelationshipsDataset {
    /**
     *
     * @type {JsonApiDatasetToOneLinkage}
     * @memberof JsonApiAttributeOutRelationshipsDataset
     */
    data: JsonApiDatasetToOneLinkage | null;
}
/**
 *
 * @export
 * @interface JsonApiAttributeOutRelationshipsDefaultView
 */
export interface JsonApiAttributeOutRelationshipsDefaultView {
    /**
     *
     * @type {JsonApiLabelToOneLinkage}
     * @memberof JsonApiAttributeOutRelationshipsDefaultView
     */
    data: JsonApiLabelToOneLinkage | null;
}
/**
 *
 * @export
 * @interface JsonApiAttributeOutWithLinks
 */
export interface JsonApiAttributeOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiAttributeOutWithLinks
     */
    type: JsonApiAttributeOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiAttributeOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiAttributeOutAttributes}
     * @memberof JsonApiAttributeOutWithLinks
     */
    attributes?: JsonApiAttributeOutAttributes;
    /**
     *
     * @type {JsonApiAttributeOutRelationships}
     * @memberof JsonApiAttributeOutWithLinks
     */
    relationships?: JsonApiAttributeOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiAttributeOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiAttributeOutWithLinksTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type JsonApiAttributeOutWithLinksTypeEnum =
    typeof JsonApiAttributeOutWithLinksTypeEnum[keyof typeof JsonApiAttributeOutWithLinksTypeEnum];

/**
 * @type JsonApiAttributeToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiAttributeToOneLinkage = JsonApiAttributeLinkage;

/**
 * JSON:API representation of cookieSecurityConfiguration entity.
 * @export
 * @interface JsonApiCookieSecurityConfigurationIn
 */
export interface JsonApiCookieSecurityConfigurationIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiCookieSecurityConfigurationIn
     */
    type: JsonApiCookieSecurityConfigurationInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiCookieSecurityConfigurationIn
     */
    id: string;
    /**
     *
     * @type {JsonApiCookieSecurityConfigurationOutAttributes}
     * @memberof JsonApiCookieSecurityConfigurationIn
     */
    attributes?: JsonApiCookieSecurityConfigurationOutAttributes;
}

export const JsonApiCookieSecurityConfigurationInTypeEnum = {
    COOKIE_SECURITY_CONFIGURATION: "cookieSecurityConfiguration",
} as const;

export type JsonApiCookieSecurityConfigurationInTypeEnum =
    typeof JsonApiCookieSecurityConfigurationInTypeEnum[keyof typeof JsonApiCookieSecurityConfigurationInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiCookieSecurityConfigurationInDocument
 */
export interface JsonApiCookieSecurityConfigurationInDocument {
    /**
     *
     * @type {JsonApiCookieSecurityConfigurationIn}
     * @memberof JsonApiCookieSecurityConfigurationInDocument
     */
    data: JsonApiCookieSecurityConfigurationIn;
}
/**
 * JSON:API representation of cookieSecurityConfiguration entity.
 * @export
 * @interface JsonApiCookieSecurityConfigurationOut
 */
export interface JsonApiCookieSecurityConfigurationOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiCookieSecurityConfigurationOut
     */
    type: JsonApiCookieSecurityConfigurationOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiCookieSecurityConfigurationOut
     */
    id: string;
    /**
     *
     * @type {JsonApiCookieSecurityConfigurationOutAttributes}
     * @memberof JsonApiCookieSecurityConfigurationOut
     */
    attributes?: JsonApiCookieSecurityConfigurationOutAttributes;
}

export const JsonApiCookieSecurityConfigurationOutTypeEnum = {
    COOKIE_SECURITY_CONFIGURATION: "cookieSecurityConfiguration",
} as const;

export type JsonApiCookieSecurityConfigurationOutTypeEnum =
    typeof JsonApiCookieSecurityConfigurationOutTypeEnum[keyof typeof JsonApiCookieSecurityConfigurationOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiCookieSecurityConfigurationOutAttributes
 */
export interface JsonApiCookieSecurityConfigurationOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiCookieSecurityConfigurationOutAttributes
     */
    lastRotation?: string;
    /**
     * Length of interval between automatic rotations expressed in format of ISO 8601 duration
     * @type {string}
     * @memberof JsonApiCookieSecurityConfigurationOutAttributes
     */
    rotationInterval?: string;
}
/**
 *
 * @export
 * @interface JsonApiCookieSecurityConfigurationOutDocument
 */
export interface JsonApiCookieSecurityConfigurationOutDocument {
    /**
     *
     * @type {JsonApiCookieSecurityConfigurationOut}
     * @memberof JsonApiCookieSecurityConfigurationOutDocument
     */
    data: JsonApiCookieSecurityConfigurationOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiCookieSecurityConfigurationOutDocument
     */
    links?: ObjectLinks;
}
/**
 * JSON:API representation of dashboardPlugin entity.
 * @export
 * @interface JsonApiDashboardPluginIn
 */
export interface JsonApiDashboardPluginIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDashboardPluginIn
     */
    type: JsonApiDashboardPluginInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDashboardPluginIn
     */
    id: string;
    /**
     *
     * @type {JsonApiDashboardPluginPatchAttributes}
     * @memberof JsonApiDashboardPluginIn
     */
    attributes?: JsonApiDashboardPluginPatchAttributes;
}

export const JsonApiDashboardPluginInTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
} as const;

export type JsonApiDashboardPluginInTypeEnum =
    typeof JsonApiDashboardPluginInTypeEnum[keyof typeof JsonApiDashboardPluginInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDashboardPluginInDocument
 */
export interface JsonApiDashboardPluginInDocument {
    /**
     *
     * @type {JsonApiDashboardPluginIn}
     * @memberof JsonApiDashboardPluginInDocument
     */
    data: JsonApiDashboardPluginIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiDashboardPluginLinkage
 */
export interface JsonApiDashboardPluginLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiDashboardPluginLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDashboardPluginLinkage
     */
    type: JsonApiDashboardPluginLinkageTypeEnum;
}

export const JsonApiDashboardPluginLinkageTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
} as const;

export type JsonApiDashboardPluginLinkageTypeEnum =
    typeof JsonApiDashboardPluginLinkageTypeEnum[keyof typeof JsonApiDashboardPluginLinkageTypeEnum];

/**
 * JSON:API representation of dashboardPlugin entity.
 * @export
 * @interface JsonApiDashboardPluginOut
 */
export interface JsonApiDashboardPluginOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDashboardPluginOut
     */
    type: JsonApiDashboardPluginOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDashboardPluginOut
     */
    id: string;
    /**
     *
     * @type {JsonApiDashboardPluginPatchAttributes}
     * @memberof JsonApiDashboardPluginOut
     */
    attributes?: JsonApiDashboardPluginPatchAttributes;
}

export const JsonApiDashboardPluginOutTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
} as const;

export type JsonApiDashboardPluginOutTypeEnum =
    typeof JsonApiDashboardPluginOutTypeEnum[keyof typeof JsonApiDashboardPluginOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDashboardPluginOutDocument
 */
export interface JsonApiDashboardPluginOutDocument {
    /**
     *
     * @type {JsonApiDashboardPluginOut}
     * @memberof JsonApiDashboardPluginOutDocument
     */
    data: JsonApiDashboardPluginOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDashboardPluginOutDocument
     */
    links?: ObjectLinks;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiDashboardPluginOutList
 */
export interface JsonApiDashboardPluginOutList {
    /**
     *
     * @type {Array<JsonApiDashboardPluginOutWithLinks>}
     * @memberof JsonApiDashboardPluginOutList
     */
    data: Array<JsonApiDashboardPluginOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiDashboardPluginOutList
     */
    links?: ListLinks;
}
/**
 *
 * @export
 * @interface JsonApiDashboardPluginOutWithLinks
 */
export interface JsonApiDashboardPluginOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDashboardPluginOutWithLinks
     */
    type: JsonApiDashboardPluginOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDashboardPluginOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiDashboardPluginPatchAttributes}
     * @memberof JsonApiDashboardPluginOutWithLinks
     */
    attributes?: JsonApiDashboardPluginPatchAttributes;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDashboardPluginOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiDashboardPluginOutWithLinksTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
} as const;

export type JsonApiDashboardPluginOutWithLinksTypeEnum =
    typeof JsonApiDashboardPluginOutWithLinksTypeEnum[keyof typeof JsonApiDashboardPluginOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching dashboardPlugin entity.
 * @export
 * @interface JsonApiDashboardPluginPatch
 */
export interface JsonApiDashboardPluginPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDashboardPluginPatch
     */
    type: JsonApiDashboardPluginPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDashboardPluginPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiDashboardPluginPatchAttributes}
     * @memberof JsonApiDashboardPluginPatch
     */
    attributes?: JsonApiDashboardPluginPatchAttributes;
}

export const JsonApiDashboardPluginPatchTypeEnum = {
    DASHBOARD_PLUGIN: "dashboardPlugin",
} as const;

export type JsonApiDashboardPluginPatchTypeEnum =
    typeof JsonApiDashboardPluginPatchTypeEnum[keyof typeof JsonApiDashboardPluginPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDashboardPluginPatchAttributes
 */
export interface JsonApiDashboardPluginPatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiDashboardPluginPatchAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDashboardPluginPatchAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiDashboardPluginPatchAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDashboardPluginPatchAttributes
     */
    areRelationsValid?: boolean;
    /**
     * Free-form JSON content.
     * @type {object}
     * @memberof JsonApiDashboardPluginPatchAttributes
     */
    content?: object;
}
/**
 *
 * @export
 * @interface JsonApiDashboardPluginPatchDocument
 */
export interface JsonApiDashboardPluginPatchDocument {
    /**
     *
     * @type {JsonApiDashboardPluginPatch}
     * @memberof JsonApiDashboardPluginPatchDocument
     */
    data: JsonApiDashboardPluginPatch;
}
/**
 * JSON:API representation of dataSourceIdentifier entity.
 * @export
 * @interface JsonApiDataSourceIdentifierOut
 */
export interface JsonApiDataSourceIdentifierOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOut
     */
    type: JsonApiDataSourceIdentifierOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOut
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceOutMeta}
     * @memberof JsonApiDataSourceIdentifierOut
     */
    meta?: JsonApiDataSourceOutMeta;
    /**
     *
     * @type {JsonApiDataSourceIdentifierOutAttributes}
     * @memberof JsonApiDataSourceIdentifierOut
     */
    attributes: JsonApiDataSourceIdentifierOutAttributes;
}

export const JsonApiDataSourceIdentifierOutTypeEnum = {
    DATA_SOURCE_IDENTIFIER: "dataSourceIdentifier",
} as const;

export type JsonApiDataSourceIdentifierOutTypeEnum =
    typeof JsonApiDataSourceIdentifierOutTypeEnum[keyof typeof JsonApiDataSourceIdentifierOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceIdentifierOutAttributes
 */
export interface JsonApiDataSourceIdentifierOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOutAttributes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOutAttributes
     */
    schema: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOutAttributes
     */
    type: JsonApiDataSourceIdentifierOutAttributesTypeEnum;
}

export const JsonApiDataSourceIdentifierOutAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
} as const;

export type JsonApiDataSourceIdentifierOutAttributesTypeEnum =
    typeof JsonApiDataSourceIdentifierOutAttributesTypeEnum[keyof typeof JsonApiDataSourceIdentifierOutAttributesTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceIdentifierOutDocument
 */
export interface JsonApiDataSourceIdentifierOutDocument {
    /**
     *
     * @type {JsonApiDataSourceIdentifierOut}
     * @memberof JsonApiDataSourceIdentifierOutDocument
     */
    data: JsonApiDataSourceIdentifierOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDataSourceIdentifierOutDocument
     */
    links?: ObjectLinks;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiDataSourceIdentifierOutList
 */
export interface JsonApiDataSourceIdentifierOutList {
    /**
     *
     * @type {Array<JsonApiDataSourceIdentifierOutWithLinks>}
     * @memberof JsonApiDataSourceIdentifierOutList
     */
    data: Array<JsonApiDataSourceIdentifierOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiDataSourceIdentifierOutList
     */
    links?: ListLinks;
}
/**
 *
 * @export
 * @interface JsonApiDataSourceIdentifierOutWithLinks
 */
export interface JsonApiDataSourceIdentifierOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOutWithLinks
     */
    type: JsonApiDataSourceIdentifierOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceIdentifierOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceOutMeta}
     * @memberof JsonApiDataSourceIdentifierOutWithLinks
     */
    meta?: JsonApiDataSourceOutMeta;
    /**
     *
     * @type {JsonApiDataSourceIdentifierOutAttributes}
     * @memberof JsonApiDataSourceIdentifierOutWithLinks
     */
    attributes: JsonApiDataSourceIdentifierOutAttributes;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDataSourceIdentifierOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiDataSourceIdentifierOutWithLinksTypeEnum = {
    DATA_SOURCE_IDENTIFIER: "dataSourceIdentifier",
} as const;

export type JsonApiDataSourceIdentifierOutWithLinksTypeEnum =
    typeof JsonApiDataSourceIdentifierOutWithLinksTypeEnum[keyof typeof JsonApiDataSourceIdentifierOutWithLinksTypeEnum];

/**
 * JSON:API representation of dataSource entity.
 * @export
 * @interface JsonApiDataSourceIn
 */
export interface JsonApiDataSourceIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceIn
     */
    type: JsonApiDataSourceInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceIn
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceInAttributes}
     * @memberof JsonApiDataSourceIn
     */
    attributes: JsonApiDataSourceInAttributes;
}

export const JsonApiDataSourceInTypeEnum = {
    DATA_SOURCE: "dataSource",
} as const;

export type JsonApiDataSourceInTypeEnum =
    typeof JsonApiDataSourceInTypeEnum[keyof typeof JsonApiDataSourceInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceInAttributes
 */
export interface JsonApiDataSourceInAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    type: JsonApiDataSourceInAttributesTypeEnum;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    url: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    schema: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceInAttributes
     */
    token?: string;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDataSourceInAttributes
     */
    enableCaching?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiDataSourceInAttributes
     */
    cachePath?: Array<string>;
}

export const JsonApiDataSourceInAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
} as const;

export type JsonApiDataSourceInAttributesTypeEnum =
    typeof JsonApiDataSourceInAttributesTypeEnum[keyof typeof JsonApiDataSourceInAttributesTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceInDocument
 */
export interface JsonApiDataSourceInDocument {
    /**
     *
     * @type {JsonApiDataSourceIn}
     * @memberof JsonApiDataSourceInDocument
     */
    data: JsonApiDataSourceIn;
}
/**
 * JSON:API representation of dataSource entity.
 * @export
 * @interface JsonApiDataSourceOut
 */
export interface JsonApiDataSourceOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceOut
     */
    type: JsonApiDataSourceOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceOut
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceOutMeta}
     * @memberof JsonApiDataSourceOut
     */
    meta?: JsonApiDataSourceOutMeta;
    /**
     *
     * @type {JsonApiDataSourceOutAttributes}
     * @memberof JsonApiDataSourceOut
     */
    attributes: JsonApiDataSourceOutAttributes;
}

export const JsonApiDataSourceOutTypeEnum = {
    DATA_SOURCE: "dataSource",
} as const;

export type JsonApiDataSourceOutTypeEnum =
    typeof JsonApiDataSourceOutTypeEnum[keyof typeof JsonApiDataSourceOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceOutAttributes
 */
export interface JsonApiDataSourceOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceOutAttributes
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceOutAttributes
     */
    type: JsonApiDataSourceOutAttributesTypeEnum;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceOutAttributes
     */
    url: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceOutAttributes
     */
    schema: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceOutAttributes
     */
    username?: string;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDataSourceOutAttributes
     */
    enableCaching?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiDataSourceOutAttributes
     */
    cachePath?: Array<string>;
}

export const JsonApiDataSourceOutAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
} as const;

export type JsonApiDataSourceOutAttributesTypeEnum =
    typeof JsonApiDataSourceOutAttributesTypeEnum[keyof typeof JsonApiDataSourceOutAttributesTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceOutDocument
 */
export interface JsonApiDataSourceOutDocument {
    /**
     *
     * @type {JsonApiDataSourceOut}
     * @memberof JsonApiDataSourceOutDocument
     */
    data: JsonApiDataSourceOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDataSourceOutDocument
     */
    links?: ObjectLinks;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiDataSourceOutList
 */
export interface JsonApiDataSourceOutList {
    /**
     *
     * @type {Array<JsonApiDataSourceOutWithLinks>}
     * @memberof JsonApiDataSourceOutList
     */
    data: Array<JsonApiDataSourceOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiDataSourceOutList
     */
    links?: ListLinks;
}
/**
 *
 * @export
 * @interface JsonApiDataSourceOutMeta
 */
export interface JsonApiDataSourceOutMeta {
    /**
     * List of valid permissions for a logged user.
     * @type {Array<string>}
     * @memberof JsonApiDataSourceOutMeta
     */
    permissions?: Array<JsonApiDataSourceOutMetaPermissionsEnum>;
}

export const JsonApiDataSourceOutMetaPermissionsEnum = {
    MANAGE: "MANAGE",
    USE: "USE",
} as const;

export type JsonApiDataSourceOutMetaPermissionsEnum =
    typeof JsonApiDataSourceOutMetaPermissionsEnum[keyof typeof JsonApiDataSourceOutMetaPermissionsEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceOutWithLinks
 */
export interface JsonApiDataSourceOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceOutWithLinks
     */
    type: JsonApiDataSourceOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceOutMeta}
     * @memberof JsonApiDataSourceOutWithLinks
     */
    meta?: JsonApiDataSourceOutMeta;
    /**
     *
     * @type {JsonApiDataSourceOutAttributes}
     * @memberof JsonApiDataSourceOutWithLinks
     */
    attributes: JsonApiDataSourceOutAttributes;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDataSourceOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiDataSourceOutWithLinksTypeEnum = {
    DATA_SOURCE: "dataSource",
} as const;

export type JsonApiDataSourceOutWithLinksTypeEnum =
    typeof JsonApiDataSourceOutWithLinksTypeEnum[keyof typeof JsonApiDataSourceOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching dataSource entity.
 * @export
 * @interface JsonApiDataSourcePatch
 */
export interface JsonApiDataSourcePatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourcePatch
     */
    type: JsonApiDataSourcePatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourcePatch
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourcePatchAttributes}
     * @memberof JsonApiDataSourcePatch
     */
    attributes: JsonApiDataSourcePatchAttributes;
}

export const JsonApiDataSourcePatchTypeEnum = {
    DATA_SOURCE: "dataSource",
} as const;

export type JsonApiDataSourcePatchTypeEnum =
    typeof JsonApiDataSourcePatchTypeEnum[keyof typeof JsonApiDataSourcePatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourcePatchAttributes
 */
export interface JsonApiDataSourcePatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    type?: JsonApiDataSourcePatchAttributesTypeEnum;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    url?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    schema?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    username?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    token?: string;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    enableCaching?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiDataSourcePatchAttributes
     */
    cachePath?: Array<string>;
}

export const JsonApiDataSourcePatchAttributesTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
} as const;

export type JsonApiDataSourcePatchAttributesTypeEnum =
    typeof JsonApiDataSourcePatchAttributesTypeEnum[keyof typeof JsonApiDataSourcePatchAttributesTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourcePatchDocument
 */
export interface JsonApiDataSourcePatchDocument {
    /**
     *
     * @type {JsonApiDataSourcePatch}
     * @memberof JsonApiDataSourcePatchDocument
     */
    data: JsonApiDataSourcePatch;
}
/**
 * Tables in data source
 * @export
 * @interface JsonApiDataSourceTableOut
 */
export interface JsonApiDataSourceTableOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceTableOut
     */
    type: JsonApiDataSourceTableOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceTableOut
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceTableOutAttributes}
     * @memberof JsonApiDataSourceTableOut
     */
    attributes: JsonApiDataSourceTableOutAttributes;
}

export const JsonApiDataSourceTableOutTypeEnum = {
    DATA_SOURCE_TABLE: "dataSourceTable",
} as const;

export type JsonApiDataSourceTableOutTypeEnum =
    typeof JsonApiDataSourceTableOutTypeEnum[keyof typeof JsonApiDataSourceTableOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceTableOutAttributes
 */
export interface JsonApiDataSourceTableOutAttributes {
    /**
     * Path to table.
     * @type {Array<string>}
     * @memberof JsonApiDataSourceTableOutAttributes
     */
    path?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceTableOutAttributes
     */
    type?: JsonApiDataSourceTableOutAttributesTypeEnum;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceTableOutAttributes
     */
    namePrefix?: string;
    /**
     *
     * @type {Array<JsonApiDataSourceTableOutAttributesColumns>}
     * @memberof JsonApiDataSourceTableOutAttributes
     */
    columns: Array<JsonApiDataSourceTableOutAttributesColumns>;
}

export const JsonApiDataSourceTableOutAttributesTypeEnum = {
    TABLE: "TABLE",
    VIEW: "VIEW",
} as const;

export type JsonApiDataSourceTableOutAttributesTypeEnum =
    typeof JsonApiDataSourceTableOutAttributesTypeEnum[keyof typeof JsonApiDataSourceTableOutAttributesTypeEnum];

/**
 * Table columns in data source
 * @export
 * @interface JsonApiDataSourceTableOutAttributesColumns
 */
export interface JsonApiDataSourceTableOutAttributesColumns {
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceTableOutAttributesColumns
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceTableOutAttributesColumns
     */
    dataType: JsonApiDataSourceTableOutAttributesColumnsDataTypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDataSourceTableOutAttributesColumns
     */
    isPrimaryKey?: boolean;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceTableOutAttributesColumns
     */
    referencedTableId?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDataSourceTableOutAttributesColumns
     */
    referencedTableColumn?: string;
}

export const JsonApiDataSourceTableOutAttributesColumnsDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    BOOLEAN: "BOOLEAN",
} as const;

export type JsonApiDataSourceTableOutAttributesColumnsDataTypeEnum =
    typeof JsonApiDataSourceTableOutAttributesColumnsDataTypeEnum[keyof typeof JsonApiDataSourceTableOutAttributesColumnsDataTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDataSourceTableOutDocument
 */
export interface JsonApiDataSourceTableOutDocument {
    /**
     *
     * @type {JsonApiDataSourceTableOut}
     * @memberof JsonApiDataSourceTableOutDocument
     */
    data: JsonApiDataSourceTableOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDataSourceTableOutDocument
     */
    links?: ObjectLinks;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiDataSourceTableOutList
 */
export interface JsonApiDataSourceTableOutList {
    /**
     *
     * @type {Array<JsonApiDataSourceTableOutWithLinks>}
     * @memberof JsonApiDataSourceTableOutList
     */
    data: Array<JsonApiDataSourceTableOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiDataSourceTableOutList
     */
    links?: ListLinks;
}
/**
 *
 * @export
 * @interface JsonApiDataSourceTableOutWithLinks
 */
export interface JsonApiDataSourceTableOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDataSourceTableOutWithLinks
     */
    type: JsonApiDataSourceTableOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDataSourceTableOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiDataSourceTableOutAttributes}
     * @memberof JsonApiDataSourceTableOutWithLinks
     */
    attributes: JsonApiDataSourceTableOutAttributes;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDataSourceTableOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiDataSourceTableOutWithLinksTypeEnum = {
    DATA_SOURCE_TABLE: "dataSourceTable",
} as const;

export type JsonApiDataSourceTableOutWithLinksTypeEnum =
    typeof JsonApiDataSourceTableOutWithLinksTypeEnum[keyof typeof JsonApiDataSourceTableOutWithLinksTypeEnum];

/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiDatasetLinkage
 */
export interface JsonApiDatasetLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetLinkage
     */
    type: JsonApiDatasetLinkageTypeEnum;
}

export const JsonApiDatasetLinkageTypeEnum = {
    DATASET: "dataset",
} as const;

export type JsonApiDatasetLinkageTypeEnum =
    typeof JsonApiDatasetLinkageTypeEnum[keyof typeof JsonApiDatasetLinkageTypeEnum];

/**
 * JSON:API representation of dataset entity.
 * @export
 * @interface JsonApiDatasetOut
 */
export interface JsonApiDatasetOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDatasetOut
     */
    type: JsonApiDatasetOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDatasetOut
     */
    id: string;
    /**
     *
     * @type {JsonApiDatasetOutAttributes}
     * @memberof JsonApiDatasetOut
     */
    attributes: JsonApiDatasetOutAttributes;
    /**
     *
     * @type {JsonApiDatasetOutRelationships}
     * @memberof JsonApiDatasetOut
     */
    relationships?: JsonApiDatasetOutRelationships;
}

export const JsonApiDatasetOutTypeEnum = {
    DATASET: "dataset",
} as const;

export type JsonApiDatasetOutTypeEnum =
    typeof JsonApiDatasetOutTypeEnum[keyof typeof JsonApiDatasetOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDatasetOutAttributes
 */
export interface JsonApiDatasetOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetOutAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetOutAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiDatasetOutAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetOutAttributes
     */
    type: JsonApiDatasetOutAttributesTypeEnum;
    /**
     *
     * @type {Array<JsonApiDatasetOutAttributesGrain>}
     * @memberof JsonApiDatasetOutAttributes
     */
    grain?: Array<JsonApiDatasetOutAttributesGrain>;
    /**
     *
     * @type {Array<JsonApiDatasetOutAttributesReferenceProperties>}
     * @memberof JsonApiDatasetOutAttributes
     */
    referenceProperties?: Array<JsonApiDatasetOutAttributesReferenceProperties>;
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetOutAttributes
     */
    dataSourceTableId?: string;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDatasetOutAttributes
     */
    areRelationsValid?: boolean;
}

export const JsonApiDatasetOutAttributesTypeEnum = {
    NORMAL: "NORMAL",
    DATE: "DATE",
} as const;

export type JsonApiDatasetOutAttributesTypeEnum =
    typeof JsonApiDatasetOutAttributesTypeEnum[keyof typeof JsonApiDatasetOutAttributesTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDatasetOutAttributesGrain
 */
export interface JsonApiDatasetOutAttributesGrain {
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetOutAttributesGrain
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiDatasetOutAttributesGrain
     */
    type: JsonApiDatasetOutAttributesGrainTypeEnum;
}

export const JsonApiDatasetOutAttributesGrainTypeEnum = {
    ATTRIBUTE: "attribute",
    DATASET: "dataset",
} as const;

export type JsonApiDatasetOutAttributesGrainTypeEnum =
    typeof JsonApiDatasetOutAttributesGrainTypeEnum[keyof typeof JsonApiDatasetOutAttributesGrainTypeEnum];

/**
 *
 * @export
 * @interface JsonApiDatasetOutAttributesReferenceProperties
 */
export interface JsonApiDatasetOutAttributesReferenceProperties {
    /**
     *
     * @type {DatasetReferenceIdentifier}
     * @memberof JsonApiDatasetOutAttributesReferenceProperties
     */
    identifier: DatasetReferenceIdentifier;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiDatasetOutAttributesReferenceProperties
     */
    multivalue: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiDatasetOutAttributesReferenceProperties
     */
    sourceColumns: Array<string>;
}
/**
 *
 * @export
 * @interface JsonApiDatasetOutDocument
 */
export interface JsonApiDatasetOutDocument {
    /**
     *
     * @type {JsonApiDatasetOut}
     * @memberof JsonApiDatasetOutDocument
     */
    data: JsonApiDatasetOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDatasetOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiDatasetOutIncludes>}
     * @memberof JsonApiDatasetOutDocument
     */
    included?: Array<JsonApiDatasetOutIncludes>;
}
/**
 * @type JsonApiDatasetOutIncludes
 * @export
 */
export type JsonApiDatasetOutIncludes =
    | JsonApiAttributeOutWithLinks
    | JsonApiDatasetOutWithLinks
    | JsonApiFactOutWithLinks;

/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiDatasetOutList
 */
export interface JsonApiDatasetOutList {
    /**
     *
     * @type {Array<JsonApiDatasetOutWithLinks>}
     * @memberof JsonApiDatasetOutList
     */
    data: Array<JsonApiDatasetOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiDatasetOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiDatasetOutIncludes>}
     * @memberof JsonApiDatasetOutList
     */
    included?: Array<JsonApiDatasetOutIncludes>;
}
/**
 *
 * @export
 * @interface JsonApiDatasetOutRelationships
 */
export interface JsonApiDatasetOutRelationships {
    /**
     *
     * @type {JsonApiFilterContextOutRelationshipsAttributes}
     * @memberof JsonApiDatasetOutRelationships
     */
    attributes?: JsonApiFilterContextOutRelationshipsAttributes;
    /**
     *
     * @type {JsonApiMetricOutRelationshipsFacts}
     * @memberof JsonApiDatasetOutRelationships
     */
    facts?: JsonApiMetricOutRelationshipsFacts;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsDatasets}
     * @memberof JsonApiDatasetOutRelationships
     */
    references?: JsonApiAnalyticalDashboardOutRelationshipsDatasets;
}
/**
 *
 * @export
 * @interface JsonApiDatasetOutWithLinks
 */
export interface JsonApiDatasetOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiDatasetOutWithLinks
     */
    type: JsonApiDatasetOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiDatasetOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiDatasetOutAttributes}
     * @memberof JsonApiDatasetOutWithLinks
     */
    attributes: JsonApiDatasetOutAttributes;
    /**
     *
     * @type {JsonApiDatasetOutRelationships}
     * @memberof JsonApiDatasetOutWithLinks
     */
    relationships?: JsonApiDatasetOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiDatasetOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiDatasetOutWithLinksTypeEnum = {
    DATASET: "dataset",
} as const;

export type JsonApiDatasetOutWithLinksTypeEnum =
    typeof JsonApiDatasetOutWithLinksTypeEnum[keyof typeof JsonApiDatasetOutWithLinksTypeEnum];

/**
 * @type JsonApiDatasetToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiDatasetToOneLinkage = JsonApiDatasetLinkage;

/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiFactLinkage
 */
export interface JsonApiFactLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiFactLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiFactLinkage
     */
    type: JsonApiFactLinkageTypeEnum;
}

export const JsonApiFactLinkageTypeEnum = {
    FACT: "fact",
} as const;

export type JsonApiFactLinkageTypeEnum =
    typeof JsonApiFactLinkageTypeEnum[keyof typeof JsonApiFactLinkageTypeEnum];

/**
 * JSON:API representation of fact entity.
 * @export
 * @interface JsonApiFactOut
 */
export interface JsonApiFactOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiFactOut
     */
    type: JsonApiFactOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiFactOut
     */
    id: string;
    /**
     *
     * @type {JsonApiFactOutAttributes}
     * @memberof JsonApiFactOut
     */
    attributes?: JsonApiFactOutAttributes;
    /**
     *
     * @type {JsonApiFactOutRelationships}
     * @memberof JsonApiFactOut
     */
    relationships?: JsonApiFactOutRelationships;
}

export const JsonApiFactOutTypeEnum = {
    FACT: "fact",
} as const;

export type JsonApiFactOutTypeEnum = typeof JsonApiFactOutTypeEnum[keyof typeof JsonApiFactOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiFactOutAttributes
 */
export interface JsonApiFactOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiFactOutAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiFactOutAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiFactOutAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof JsonApiFactOutAttributes
     */
    sourceColumn?: string;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiFactOutAttributes
     */
    areRelationsValid?: boolean;
}
/**
 *
 * @export
 * @interface JsonApiFactOutDocument
 */
export interface JsonApiFactOutDocument {
    /**
     *
     * @type {JsonApiFactOut}
     * @memberof JsonApiFactOutDocument
     */
    data: JsonApiFactOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiFactOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiDatasetOutWithLinks>}
     * @memberof JsonApiFactOutDocument
     */
    included?: Array<JsonApiDatasetOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiFactOutList
 */
export interface JsonApiFactOutList {
    /**
     *
     * @type {Array<JsonApiFactOutWithLinks>}
     * @memberof JsonApiFactOutList
     */
    data: Array<JsonApiFactOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiFactOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiDatasetOutWithLinks>}
     * @memberof JsonApiFactOutList
     */
    included?: Array<JsonApiDatasetOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiFactOutRelationships
 */
export interface JsonApiFactOutRelationships {
    /**
     *
     * @type {JsonApiAttributeOutRelationshipsDataset}
     * @memberof JsonApiFactOutRelationships
     */
    dataset?: JsonApiAttributeOutRelationshipsDataset;
}
/**
 *
 * @export
 * @interface JsonApiFactOutWithLinks
 */
export interface JsonApiFactOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiFactOutWithLinks
     */
    type: JsonApiFactOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiFactOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiFactOutAttributes}
     * @memberof JsonApiFactOutWithLinks
     */
    attributes?: JsonApiFactOutAttributes;
    /**
     *
     * @type {JsonApiFactOutRelationships}
     * @memberof JsonApiFactOutWithLinks
     */
    relationships?: JsonApiFactOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiFactOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiFactOutWithLinksTypeEnum = {
    FACT: "fact",
} as const;

export type JsonApiFactOutWithLinksTypeEnum =
    typeof JsonApiFactOutWithLinksTypeEnum[keyof typeof JsonApiFactOutWithLinksTypeEnum];

/**
 * JSON:API representation of filterContext entity.
 * @export
 * @interface JsonApiFilterContextIn
 */
export interface JsonApiFilterContextIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiFilterContextIn
     */
    type: JsonApiFilterContextInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiFilterContextIn
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiFilterContextIn
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
}

export const JsonApiFilterContextInTypeEnum = {
    FILTER_CONTEXT: "filterContext",
} as const;

export type JsonApiFilterContextInTypeEnum =
    typeof JsonApiFilterContextInTypeEnum[keyof typeof JsonApiFilterContextInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiFilterContextInDocument
 */
export interface JsonApiFilterContextInDocument {
    /**
     *
     * @type {JsonApiFilterContextIn}
     * @memberof JsonApiFilterContextInDocument
     */
    data: JsonApiFilterContextIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiFilterContextLinkage
 */
export interface JsonApiFilterContextLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiFilterContextLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiFilterContextLinkage
     */
    type: JsonApiFilterContextLinkageTypeEnum;
}

export const JsonApiFilterContextLinkageTypeEnum = {
    FILTER_CONTEXT: "filterContext",
} as const;

export type JsonApiFilterContextLinkageTypeEnum =
    typeof JsonApiFilterContextLinkageTypeEnum[keyof typeof JsonApiFilterContextLinkageTypeEnum];

/**
 * JSON:API representation of filterContext entity.
 * @export
 * @interface JsonApiFilterContextOut
 */
export interface JsonApiFilterContextOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiFilterContextOut
     */
    type: JsonApiFilterContextOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiFilterContextOut
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiFilterContextOut
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
    /**
     *
     * @type {JsonApiFilterContextOutRelationships}
     * @memberof JsonApiFilterContextOut
     */
    relationships?: JsonApiFilterContextOutRelationships;
}

export const JsonApiFilterContextOutTypeEnum = {
    FILTER_CONTEXT: "filterContext",
} as const;

export type JsonApiFilterContextOutTypeEnum =
    typeof JsonApiFilterContextOutTypeEnum[keyof typeof JsonApiFilterContextOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiFilterContextOutDocument
 */
export interface JsonApiFilterContextOutDocument {
    /**
     *
     * @type {JsonApiFilterContextOut}
     * @memberof JsonApiFilterContextOutDocument
     */
    data: JsonApiFilterContextOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiFilterContextOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiFilterContextOutIncludes>}
     * @memberof JsonApiFilterContextOutDocument
     */
    included?: Array<JsonApiFilterContextOutIncludes>;
}
/**
 * @type JsonApiFilterContextOutIncludes
 * @export
 */
export type JsonApiFilterContextOutIncludes =
    | JsonApiAttributeOutWithLinks
    | JsonApiDatasetOutWithLinks
    | JsonApiLabelOutWithLinks;

/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiFilterContextOutList
 */
export interface JsonApiFilterContextOutList {
    /**
     *
     * @type {Array<JsonApiFilterContextOutWithLinks>}
     * @memberof JsonApiFilterContextOutList
     */
    data: Array<JsonApiFilterContextOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiFilterContextOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiFilterContextOutIncludes>}
     * @memberof JsonApiFilterContextOutList
     */
    included?: Array<JsonApiFilterContextOutIncludes>;
}
/**
 *
 * @export
 * @interface JsonApiFilterContextOutRelationships
 */
export interface JsonApiFilterContextOutRelationships {
    /**
     *
     * @type {JsonApiFilterContextOutRelationshipsAttributes}
     * @memberof JsonApiFilterContextOutRelationships
     */
    attributes?: JsonApiFilterContextOutRelationshipsAttributes;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsDatasets}
     * @memberof JsonApiFilterContextOutRelationships
     */
    datasets?: JsonApiAnalyticalDashboardOutRelationshipsDatasets;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsLabels}
     * @memberof JsonApiFilterContextOutRelationships
     */
    labels?: JsonApiAnalyticalDashboardOutRelationshipsLabels;
}
/**
 *
 * @export
 * @interface JsonApiFilterContextOutRelationshipsAttributes
 */
export interface JsonApiFilterContextOutRelationshipsAttributes {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiAttributeLinkage>}
     * @memberof JsonApiFilterContextOutRelationshipsAttributes
     */
    data: Array<JsonApiAttributeLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiFilterContextOutWithLinks
 */
export interface JsonApiFilterContextOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiFilterContextOutWithLinks
     */
    type: JsonApiFilterContextOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiFilterContextOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiFilterContextOutWithLinks
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
    /**
     *
     * @type {JsonApiFilterContextOutRelationships}
     * @memberof JsonApiFilterContextOutWithLinks
     */
    relationships?: JsonApiFilterContextOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiFilterContextOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiFilterContextOutWithLinksTypeEnum = {
    FILTER_CONTEXT: "filterContext",
} as const;

export type JsonApiFilterContextOutWithLinksTypeEnum =
    typeof JsonApiFilterContextOutWithLinksTypeEnum[keyof typeof JsonApiFilterContextOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching filterContext entity.
 * @export
 * @interface JsonApiFilterContextPatch
 */
export interface JsonApiFilterContextPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiFilterContextPatch
     */
    type: JsonApiFilterContextPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiFilterContextPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiFilterContextPatch
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
}

export const JsonApiFilterContextPatchTypeEnum = {
    FILTER_CONTEXT: "filterContext",
} as const;

export type JsonApiFilterContextPatchTypeEnum =
    typeof JsonApiFilterContextPatchTypeEnum[keyof typeof JsonApiFilterContextPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiFilterContextPatchDocument
 */
export interface JsonApiFilterContextPatchDocument {
    /**
     *
     * @type {JsonApiFilterContextPatch}
     * @memberof JsonApiFilterContextPatchDocument
     */
    data: JsonApiFilterContextPatch;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiLabelLinkage
 */
export interface JsonApiLabelLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiLabelLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiLabelLinkage
     */
    type: JsonApiLabelLinkageTypeEnum;
}

export const JsonApiLabelLinkageTypeEnum = {
    LABEL: "label",
} as const;

export type JsonApiLabelLinkageTypeEnum =
    typeof JsonApiLabelLinkageTypeEnum[keyof typeof JsonApiLabelLinkageTypeEnum];

/**
 * JSON:API representation of label entity.
 * @export
 * @interface JsonApiLabelOut
 */
export interface JsonApiLabelOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiLabelOut
     */
    type: JsonApiLabelOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiLabelOut
     */
    id: string;
    /**
     *
     * @type {JsonApiLabelOutAttributes}
     * @memberof JsonApiLabelOut
     */
    attributes?: JsonApiLabelOutAttributes;
    /**
     *
     * @type {JsonApiLabelOutRelationships}
     * @memberof JsonApiLabelOut
     */
    relationships?: JsonApiLabelOutRelationships;
}

export const JsonApiLabelOutTypeEnum = {
    LABEL: "label",
} as const;

export type JsonApiLabelOutTypeEnum = typeof JsonApiLabelOutTypeEnum[keyof typeof JsonApiLabelOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiLabelOutAttributes
 */
export interface JsonApiLabelOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiLabelOutAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiLabelOutAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiLabelOutAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiLabelOutAttributes
     */
    primary?: boolean;
    /**
     *
     * @type {string}
     * @memberof JsonApiLabelOutAttributes
     */
    sourceColumn?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiLabelOutAttributes
     */
    valueType?: JsonApiLabelOutAttributesValueTypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiLabelOutAttributes
     */
    areRelationsValid?: boolean;
}

export const JsonApiLabelOutAttributesValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
} as const;

export type JsonApiLabelOutAttributesValueTypeEnum =
    typeof JsonApiLabelOutAttributesValueTypeEnum[keyof typeof JsonApiLabelOutAttributesValueTypeEnum];

/**
 *
 * @export
 * @interface JsonApiLabelOutDocument
 */
export interface JsonApiLabelOutDocument {
    /**
     *
     * @type {JsonApiLabelOut}
     * @memberof JsonApiLabelOutDocument
     */
    data: JsonApiLabelOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiLabelOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiAttributeOutWithLinks>}
     * @memberof JsonApiLabelOutDocument
     */
    included?: Array<JsonApiAttributeOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiLabelOutList
 */
export interface JsonApiLabelOutList {
    /**
     *
     * @type {Array<JsonApiLabelOutWithLinks>}
     * @memberof JsonApiLabelOutList
     */
    data: Array<JsonApiLabelOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiLabelOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiAttributeOutWithLinks>}
     * @memberof JsonApiLabelOutList
     */
    included?: Array<JsonApiAttributeOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiLabelOutRelationships
 */
export interface JsonApiLabelOutRelationships {
    /**
     *
     * @type {JsonApiLabelOutRelationshipsAttribute}
     * @memberof JsonApiLabelOutRelationships
     */
    attribute?: JsonApiLabelOutRelationshipsAttribute;
}
/**
 *
 * @export
 * @interface JsonApiLabelOutRelationshipsAttribute
 */
export interface JsonApiLabelOutRelationshipsAttribute {
    /**
     *
     * @type {JsonApiAttributeToOneLinkage}
     * @memberof JsonApiLabelOutRelationshipsAttribute
     */
    data: JsonApiAttributeToOneLinkage | null;
}
/**
 *
 * @export
 * @interface JsonApiLabelOutWithLinks
 */
export interface JsonApiLabelOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiLabelOutWithLinks
     */
    type: JsonApiLabelOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiLabelOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiLabelOutAttributes}
     * @memberof JsonApiLabelOutWithLinks
     */
    attributes?: JsonApiLabelOutAttributes;
    /**
     *
     * @type {JsonApiLabelOutRelationships}
     * @memberof JsonApiLabelOutWithLinks
     */
    relationships?: JsonApiLabelOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiLabelOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiLabelOutWithLinksTypeEnum = {
    LABEL: "label",
} as const;

export type JsonApiLabelOutWithLinksTypeEnum =
    typeof JsonApiLabelOutWithLinksTypeEnum[keyof typeof JsonApiLabelOutWithLinksTypeEnum];

/**
 * @type JsonApiLabelToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiLabelToOneLinkage = JsonApiLabelLinkage;

/**
 * JSON:API representation of metric entity.
 * @export
 * @interface JsonApiMetricIn
 */
export interface JsonApiMetricIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiMetricIn
     */
    type: JsonApiMetricInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiMetricIn
     */
    id: string;
    /**
     *
     * @type {JsonApiMetricOutAttributes}
     * @memberof JsonApiMetricIn
     */
    attributes: JsonApiMetricOutAttributes;
}

export const JsonApiMetricInTypeEnum = {
    METRIC: "metric",
} as const;

export type JsonApiMetricInTypeEnum = typeof JsonApiMetricInTypeEnum[keyof typeof JsonApiMetricInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiMetricInDocument
 */
export interface JsonApiMetricInDocument {
    /**
     *
     * @type {JsonApiMetricIn}
     * @memberof JsonApiMetricInDocument
     */
    data: JsonApiMetricIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiMetricLinkage
 */
export interface JsonApiMetricLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricLinkage
     */
    type: JsonApiMetricLinkageTypeEnum;
}

export const JsonApiMetricLinkageTypeEnum = {
    METRIC: "metric",
} as const;

export type JsonApiMetricLinkageTypeEnum =
    typeof JsonApiMetricLinkageTypeEnum[keyof typeof JsonApiMetricLinkageTypeEnum];

/**
 * JSON:API representation of metric entity.
 * @export
 * @interface JsonApiMetricOut
 */
export interface JsonApiMetricOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiMetricOut
     */
    type: JsonApiMetricOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiMetricOut
     */
    id: string;
    /**
     *
     * @type {JsonApiMetricOutAttributes}
     * @memberof JsonApiMetricOut
     */
    attributes: JsonApiMetricOutAttributes;
    /**
     *
     * @type {JsonApiMetricOutRelationships}
     * @memberof JsonApiMetricOut
     */
    relationships?: JsonApiMetricOutRelationships;
}

export const JsonApiMetricOutTypeEnum = {
    METRIC: "metric",
} as const;

export type JsonApiMetricOutTypeEnum = typeof JsonApiMetricOutTypeEnum[keyof typeof JsonApiMetricOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiMetricOutAttributes
 */
export interface JsonApiMetricOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricOutAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricOutAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiMetricOutAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiMetricOutAttributes
     */
    areRelationsValid?: boolean;
    /**
     *
     * @type {JsonApiMetricPatchAttributesContent}
     * @memberof JsonApiMetricOutAttributes
     */
    content: JsonApiMetricPatchAttributesContent;
}
/**
 *
 * @export
 * @interface JsonApiMetricOutDocument
 */
export interface JsonApiMetricOutDocument {
    /**
     *
     * @type {JsonApiMetricOut}
     * @memberof JsonApiMetricOutDocument
     */
    data: JsonApiMetricOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiMetricOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiMetricOutIncludes>}
     * @memberof JsonApiMetricOutDocument
     */
    included?: Array<JsonApiMetricOutIncludes>;
}
/**
 * @type JsonApiMetricOutIncludes
 * @export
 */
export type JsonApiMetricOutIncludes =
    | JsonApiAttributeOutWithLinks
    | JsonApiFactOutWithLinks
    | JsonApiLabelOutWithLinks
    | JsonApiMetricOutWithLinks;

/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiMetricOutList
 */
export interface JsonApiMetricOutList {
    /**
     *
     * @type {Array<JsonApiMetricOutWithLinks>}
     * @memberof JsonApiMetricOutList
     */
    data: Array<JsonApiMetricOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiMetricOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiMetricOutIncludes>}
     * @memberof JsonApiMetricOutList
     */
    included?: Array<JsonApiMetricOutIncludes>;
}
/**
 *
 * @export
 * @interface JsonApiMetricOutRelationships
 */
export interface JsonApiMetricOutRelationships {
    /**
     *
     * @type {JsonApiMetricOutRelationshipsFacts}
     * @memberof JsonApiMetricOutRelationships
     */
    facts?: JsonApiMetricOutRelationshipsFacts;
    /**
     *
     * @type {JsonApiFilterContextOutRelationshipsAttributes}
     * @memberof JsonApiMetricOutRelationships
     */
    attributes?: JsonApiFilterContextOutRelationshipsAttributes;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsLabels}
     * @memberof JsonApiMetricOutRelationships
     */
    labels?: JsonApiAnalyticalDashboardOutRelationshipsLabels;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsMetrics}
     * @memberof JsonApiMetricOutRelationships
     */
    metrics?: JsonApiAnalyticalDashboardOutRelationshipsMetrics;
}
/**
 *
 * @export
 * @interface JsonApiMetricOutRelationshipsFacts
 */
export interface JsonApiMetricOutRelationshipsFacts {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiFactLinkage>}
     * @memberof JsonApiMetricOutRelationshipsFacts
     */
    data: Array<JsonApiFactLinkage>;
}
/**
 *
 * @export
 * @interface JsonApiMetricOutWithLinks
 */
export interface JsonApiMetricOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiMetricOutWithLinks
     */
    type: JsonApiMetricOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiMetricOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiMetricOutAttributes}
     * @memberof JsonApiMetricOutWithLinks
     */
    attributes: JsonApiMetricOutAttributes;
    /**
     *
     * @type {JsonApiMetricOutRelationships}
     * @memberof JsonApiMetricOutWithLinks
     */
    relationships?: JsonApiMetricOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiMetricOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiMetricOutWithLinksTypeEnum = {
    METRIC: "metric",
} as const;

export type JsonApiMetricOutWithLinksTypeEnum =
    typeof JsonApiMetricOutWithLinksTypeEnum[keyof typeof JsonApiMetricOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching metric entity.
 * @export
 * @interface JsonApiMetricPatch
 */
export interface JsonApiMetricPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiMetricPatch
     */
    type: JsonApiMetricPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiMetricPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiMetricPatchAttributes}
     * @memberof JsonApiMetricPatch
     */
    attributes: JsonApiMetricPatchAttributes;
}

export const JsonApiMetricPatchTypeEnum = {
    METRIC: "metric",
} as const;

export type JsonApiMetricPatchTypeEnum =
    typeof JsonApiMetricPatchTypeEnum[keyof typeof JsonApiMetricPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiMetricPatchAttributes
 */
export interface JsonApiMetricPatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricPatchAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricPatchAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiMetricPatchAttributes
     */
    tags?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof JsonApiMetricPatchAttributes
     */
    areRelationsValid?: boolean;
    /**
     *
     * @type {JsonApiMetricPatchAttributesContent}
     * @memberof JsonApiMetricPatchAttributes
     */
    content?: JsonApiMetricPatchAttributesContent;
}
/**
 *
 * @export
 * @interface JsonApiMetricPatchAttributesContent
 */
export interface JsonApiMetricPatchAttributesContent {
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricPatchAttributesContent
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiMetricPatchAttributesContent
     */
    maql: string;
}
/**
 *
 * @export
 * @interface JsonApiMetricPatchDocument
 */
export interface JsonApiMetricPatchDocument {
    /**
     *
     * @type {JsonApiMetricPatch}
     * @memberof JsonApiMetricPatchDocument
     */
    data: JsonApiMetricPatch;
}
/**
 * JSON:API representation of organization entity.
 * @export
 * @interface JsonApiOrganizationIn
 */
export interface JsonApiOrganizationIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiOrganizationIn
     */
    type: JsonApiOrganizationInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiOrganizationIn
     */
    id: string;
    /**
     *
     * @type {JsonApiOrganizationInAttributes}
     * @memberof JsonApiOrganizationIn
     */
    attributes?: JsonApiOrganizationInAttributes;
}

export const JsonApiOrganizationInTypeEnum = {
    ORGANIZATION: "organization",
} as const;

export type JsonApiOrganizationInTypeEnum =
    typeof JsonApiOrganizationInTypeEnum[keyof typeof JsonApiOrganizationInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiOrganizationInAttributes
 */
export interface JsonApiOrganizationInAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationInAttributes
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationInAttributes
     */
    hostname?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiOrganizationInAttributes
     */
    allowedOrigins?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationInAttributes
     */
    oauthIssuerLocation?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationInAttributes
     */
    oauthClientId?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationInAttributes
     */
    oauthClientSecret?: string;
}
/**
 *
 * @export
 * @interface JsonApiOrganizationInDocument
 */
export interface JsonApiOrganizationInDocument {
    /**
     *
     * @type {JsonApiOrganizationIn}
     * @memberof JsonApiOrganizationInDocument
     */
    data: JsonApiOrganizationIn;
}
/**
 * JSON:API representation of organization entity.
 * @export
 * @interface JsonApiOrganizationOut
 */
export interface JsonApiOrganizationOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiOrganizationOut
     */
    type: JsonApiOrganizationOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiOrganizationOut
     */
    id: string;
    /**
     *
     * @type {JsonApiOrganizationOutMeta}
     * @memberof JsonApiOrganizationOut
     */
    meta?: JsonApiOrganizationOutMeta;
    /**
     *
     * @type {JsonApiOrganizationOutAttributes}
     * @memberof JsonApiOrganizationOut
     */
    attributes?: JsonApiOrganizationOutAttributes;
    /**
     *
     * @type {JsonApiOrganizationOutRelationships}
     * @memberof JsonApiOrganizationOut
     */
    relationships?: JsonApiOrganizationOutRelationships;
}

export const JsonApiOrganizationOutTypeEnum = {
    ORGANIZATION: "organization",
} as const;

export type JsonApiOrganizationOutTypeEnum =
    typeof JsonApiOrganizationOutTypeEnum[keyof typeof JsonApiOrganizationOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiOrganizationOutAttributes
 */
export interface JsonApiOrganizationOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationOutAttributes
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationOutAttributes
     */
    hostname?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiOrganizationOutAttributes
     */
    allowedOrigins?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationOutAttributes
     */
    oauthIssuerLocation?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiOrganizationOutAttributes
     */
    oauthClientId?: string;
}
/**
 *
 * @export
 * @interface JsonApiOrganizationOutDocument
 */
export interface JsonApiOrganizationOutDocument {
    /**
     *
     * @type {JsonApiOrganizationOut}
     * @memberof JsonApiOrganizationOutDocument
     */
    data: JsonApiOrganizationOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiOrganizationOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiOrganizationOutIncludes>}
     * @memberof JsonApiOrganizationOutDocument
     */
    included?: Array<JsonApiOrganizationOutIncludes>;
}
/**
 * @type JsonApiOrganizationOutIncludes
 * @export
 */
export type JsonApiOrganizationOutIncludes = JsonApiUserGroupOutWithLinks | JsonApiUserOutWithLinks;

/**
 *
 * @export
 * @interface JsonApiOrganizationOutMeta
 */
export interface JsonApiOrganizationOutMeta {
    /**
     * List of valid permissions for a logged user.
     * @type {Array<string>}
     * @memberof JsonApiOrganizationOutMeta
     */
    permissions?: Array<JsonApiOrganizationOutMetaPermissionsEnum>;
}

export const JsonApiOrganizationOutMetaPermissionsEnum = {
    MANAGE: "MANAGE",
} as const;

export type JsonApiOrganizationOutMetaPermissionsEnum =
    typeof JsonApiOrganizationOutMetaPermissionsEnum[keyof typeof JsonApiOrganizationOutMetaPermissionsEnum];

/**
 *
 * @export
 * @interface JsonApiOrganizationOutRelationships
 */
export interface JsonApiOrganizationOutRelationships {
    /**
     *
     * @type {JsonApiOrganizationOutRelationshipsBootstrapUser}
     * @memberof JsonApiOrganizationOutRelationships
     */
    bootstrapUser?: JsonApiOrganizationOutRelationshipsBootstrapUser;
    /**
     *
     * @type {JsonApiOrganizationOutRelationshipsBootstrapUserGroup}
     * @memberof JsonApiOrganizationOutRelationships
     */
    bootstrapUserGroup?: JsonApiOrganizationOutRelationshipsBootstrapUserGroup;
}
/**
 *
 * @export
 * @interface JsonApiOrganizationOutRelationshipsBootstrapUser
 */
export interface JsonApiOrganizationOutRelationshipsBootstrapUser {
    /**
     *
     * @type {JsonApiUserToOneLinkage}
     * @memberof JsonApiOrganizationOutRelationshipsBootstrapUser
     */
    data: JsonApiUserToOneLinkage | null;
}
/**
 *
 * @export
 * @interface JsonApiOrganizationOutRelationshipsBootstrapUserGroup
 */
export interface JsonApiOrganizationOutRelationshipsBootstrapUserGroup {
    /**
     *
     * @type {JsonApiUserGroupToOneLinkage}
     * @memberof JsonApiOrganizationOutRelationshipsBootstrapUserGroup
     */
    data: JsonApiUserGroupToOneLinkage | null;
}
/**
 * JSON:API representation of userGroup entity.
 * @export
 * @interface JsonApiUserGroupIn
 */
export interface JsonApiUserGroupIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserGroupIn
     */
    type: JsonApiUserGroupInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserGroupIn
     */
    id: string;
    /**
     *
     * @type {JsonApiUserGroupPatchRelationships}
     * @memberof JsonApiUserGroupIn
     */
    relationships?: JsonApiUserGroupPatchRelationships;
}

export const JsonApiUserGroupInTypeEnum = {
    USER_GROUP: "userGroup",
} as const;

export type JsonApiUserGroupInTypeEnum =
    typeof JsonApiUserGroupInTypeEnum[keyof typeof JsonApiUserGroupInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiUserGroupInDocument
 */
export interface JsonApiUserGroupInDocument {
    /**
     *
     * @type {JsonApiUserGroupIn}
     * @memberof JsonApiUserGroupInDocument
     */
    data: JsonApiUserGroupIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiUserGroupLinkage
 */
export interface JsonApiUserGroupLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiUserGroupLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiUserGroupLinkage
     */
    type: JsonApiUserGroupLinkageTypeEnum;
}

export const JsonApiUserGroupLinkageTypeEnum = {
    USER_GROUP: "userGroup",
} as const;

export type JsonApiUserGroupLinkageTypeEnum =
    typeof JsonApiUserGroupLinkageTypeEnum[keyof typeof JsonApiUserGroupLinkageTypeEnum];

/**
 * JSON:API representation of userGroup entity.
 * @export
 * @interface JsonApiUserGroupOut
 */
export interface JsonApiUserGroupOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserGroupOut
     */
    type: JsonApiUserGroupOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserGroupOut
     */
    id: string;
    /**
     *
     * @type {JsonApiUserGroupPatchRelationships}
     * @memberof JsonApiUserGroupOut
     */
    relationships?: JsonApiUserGroupPatchRelationships;
}

export const JsonApiUserGroupOutTypeEnum = {
    USER_GROUP: "userGroup",
} as const;

export type JsonApiUserGroupOutTypeEnum =
    typeof JsonApiUserGroupOutTypeEnum[keyof typeof JsonApiUserGroupOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiUserGroupOutDocument
 */
export interface JsonApiUserGroupOutDocument {
    /**
     *
     * @type {JsonApiUserGroupOut}
     * @memberof JsonApiUserGroupOutDocument
     */
    data: JsonApiUserGroupOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiUserGroupOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiUserGroupOutWithLinks>}
     * @memberof JsonApiUserGroupOutDocument
     */
    included?: Array<JsonApiUserGroupOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiUserGroupOutList
 */
export interface JsonApiUserGroupOutList {
    /**
     *
     * @type {Array<JsonApiUserGroupOutWithLinks>}
     * @memberof JsonApiUserGroupOutList
     */
    data: Array<JsonApiUserGroupOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiUserGroupOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiUserGroupOutWithLinks>}
     * @memberof JsonApiUserGroupOutList
     */
    included?: Array<JsonApiUserGroupOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiUserGroupOutWithLinks
 */
export interface JsonApiUserGroupOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserGroupOutWithLinks
     */
    type: JsonApiUserGroupOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserGroupOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiUserGroupPatchRelationships}
     * @memberof JsonApiUserGroupOutWithLinks
     */
    relationships?: JsonApiUserGroupPatchRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiUserGroupOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiUserGroupOutWithLinksTypeEnum = {
    USER_GROUP: "userGroup",
} as const;

export type JsonApiUserGroupOutWithLinksTypeEnum =
    typeof JsonApiUserGroupOutWithLinksTypeEnum[keyof typeof JsonApiUserGroupOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching userGroup entity.
 * @export
 * @interface JsonApiUserGroupPatch
 */
export interface JsonApiUserGroupPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserGroupPatch
     */
    type: JsonApiUserGroupPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserGroupPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiUserGroupPatchRelationships}
     * @memberof JsonApiUserGroupPatch
     */
    relationships?: JsonApiUserGroupPatchRelationships;
}

export const JsonApiUserGroupPatchTypeEnum = {
    USER_GROUP: "userGroup",
} as const;

export type JsonApiUserGroupPatchTypeEnum =
    typeof JsonApiUserGroupPatchTypeEnum[keyof typeof JsonApiUserGroupPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiUserGroupPatchDocument
 */
export interface JsonApiUserGroupPatchDocument {
    /**
     *
     * @type {JsonApiUserGroupPatch}
     * @memberof JsonApiUserGroupPatchDocument
     */
    data: JsonApiUserGroupPatch;
}
/**
 *
 * @export
 * @interface JsonApiUserGroupPatchRelationships
 */
export interface JsonApiUserGroupPatchRelationships {
    /**
     *
     * @type {JsonApiUserGroupPatchRelationshipsParents}
     * @memberof JsonApiUserGroupPatchRelationships
     */
    parents?: JsonApiUserGroupPatchRelationshipsParents;
}
/**
 *
 * @export
 * @interface JsonApiUserGroupPatchRelationshipsParents
 */
export interface JsonApiUserGroupPatchRelationshipsParents {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiUserGroupLinkage>}
     * @memberof JsonApiUserGroupPatchRelationshipsParents
     */
    data: Array<JsonApiUserGroupLinkage>;
}
/**
 * @type JsonApiUserGroupToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiUserGroupToOneLinkage = JsonApiUserGroupLinkage;

/**
 * JSON:API representation of user entity.
 * @export
 * @interface JsonApiUserIn
 */
export interface JsonApiUserIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserIn
     */
    type: JsonApiUserInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserIn
     */
    id: string;
    /**
     *
     * @type {JsonApiUserPatchAttributes}
     * @memberof JsonApiUserIn
     */
    attributes?: JsonApiUserPatchAttributes;
    /**
     *
     * @type {JsonApiUserPatchRelationships}
     * @memberof JsonApiUserIn
     */
    relationships?: JsonApiUserPatchRelationships;
}

export const JsonApiUserInTypeEnum = {
    USER: "user",
} as const;

export type JsonApiUserInTypeEnum = typeof JsonApiUserInTypeEnum[keyof typeof JsonApiUserInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiUserInDocument
 */
export interface JsonApiUserInDocument {
    /**
     *
     * @type {JsonApiUserIn}
     * @memberof JsonApiUserInDocument
     */
    data: JsonApiUserIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiUserLinkage
 */
export interface JsonApiUserLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiUserLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiUserLinkage
     */
    type: JsonApiUserLinkageTypeEnum;
}

export const JsonApiUserLinkageTypeEnum = {
    USER: "user",
} as const;

export type JsonApiUserLinkageTypeEnum =
    typeof JsonApiUserLinkageTypeEnum[keyof typeof JsonApiUserLinkageTypeEnum];

/**
 * JSON:API representation of user entity.
 * @export
 * @interface JsonApiUserOut
 */
export interface JsonApiUserOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserOut
     */
    type: JsonApiUserOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserOut
     */
    id: string;
    /**
     *
     * @type {JsonApiUserPatchAttributes}
     * @memberof JsonApiUserOut
     */
    attributes?: JsonApiUserPatchAttributes;
    /**
     *
     * @type {JsonApiUserPatchRelationships}
     * @memberof JsonApiUserOut
     */
    relationships?: JsonApiUserPatchRelationships;
}

export const JsonApiUserOutTypeEnum = {
    USER: "user",
} as const;

export type JsonApiUserOutTypeEnum = typeof JsonApiUserOutTypeEnum[keyof typeof JsonApiUserOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiUserOutDocument
 */
export interface JsonApiUserOutDocument {
    /**
     *
     * @type {JsonApiUserOut}
     * @memberof JsonApiUserOutDocument
     */
    data: JsonApiUserOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiUserOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiUserGroupOutWithLinks>}
     * @memberof JsonApiUserOutDocument
     */
    included?: Array<JsonApiUserGroupOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiUserOutList
 */
export interface JsonApiUserOutList {
    /**
     *
     * @type {Array<JsonApiUserOutWithLinks>}
     * @memberof JsonApiUserOutList
     */
    data: Array<JsonApiUserOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiUserOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiUserGroupOutWithLinks>}
     * @memberof JsonApiUserOutList
     */
    included?: Array<JsonApiUserGroupOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiUserOutWithLinks
 */
export interface JsonApiUserOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserOutWithLinks
     */
    type: JsonApiUserOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiUserPatchAttributes}
     * @memberof JsonApiUserOutWithLinks
     */
    attributes?: JsonApiUserPatchAttributes;
    /**
     *
     * @type {JsonApiUserPatchRelationships}
     * @memberof JsonApiUserOutWithLinks
     */
    relationships?: JsonApiUserPatchRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiUserOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiUserOutWithLinksTypeEnum = {
    USER: "user",
} as const;

export type JsonApiUserOutWithLinksTypeEnum =
    typeof JsonApiUserOutWithLinksTypeEnum[keyof typeof JsonApiUserOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching user entity.
 * @export
 * @interface JsonApiUserPatch
 */
export interface JsonApiUserPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiUserPatch
     */
    type: JsonApiUserPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiUserPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiUserPatchAttributes}
     * @memberof JsonApiUserPatch
     */
    attributes?: JsonApiUserPatchAttributes;
    /**
     *
     * @type {JsonApiUserPatchRelationships}
     * @memberof JsonApiUserPatch
     */
    relationships?: JsonApiUserPatchRelationships;
}

export const JsonApiUserPatchTypeEnum = {
    USER: "user",
} as const;

export type JsonApiUserPatchTypeEnum = typeof JsonApiUserPatchTypeEnum[keyof typeof JsonApiUserPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiUserPatchAttributes
 */
export interface JsonApiUserPatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiUserPatchAttributes
     */
    authenticationId?: string;
}
/**
 *
 * @export
 * @interface JsonApiUserPatchDocument
 */
export interface JsonApiUserPatchDocument {
    /**
     *
     * @type {JsonApiUserPatch}
     * @memberof JsonApiUserPatchDocument
     */
    data: JsonApiUserPatch;
}
/**
 *
 * @export
 * @interface JsonApiUserPatchRelationships
 */
export interface JsonApiUserPatchRelationships {
    /**
     *
     * @type {JsonApiUserGroupPatchRelationshipsParents}
     * @memberof JsonApiUserPatchRelationships
     */
    userGroups?: JsonApiUserGroupPatchRelationshipsParents;
}
/**
 * @type JsonApiUserToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiUserToOneLinkage = JsonApiUserLinkage;

/**
 * JSON:API representation of visualizationObject entity.
 * @export
 * @interface JsonApiVisualizationObjectIn
 */
export interface JsonApiVisualizationObjectIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiVisualizationObjectIn
     */
    type: JsonApiVisualizationObjectInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiVisualizationObjectIn
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiVisualizationObjectIn
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
}

export const JsonApiVisualizationObjectInTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
} as const;

export type JsonApiVisualizationObjectInTypeEnum =
    typeof JsonApiVisualizationObjectInTypeEnum[keyof typeof JsonApiVisualizationObjectInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiVisualizationObjectInDocument
 */
export interface JsonApiVisualizationObjectInDocument {
    /**
     *
     * @type {JsonApiVisualizationObjectIn}
     * @memberof JsonApiVisualizationObjectInDocument
     */
    data: JsonApiVisualizationObjectIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiVisualizationObjectLinkage
 */
export interface JsonApiVisualizationObjectLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiVisualizationObjectLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiVisualizationObjectLinkage
     */
    type: JsonApiVisualizationObjectLinkageTypeEnum;
}

export const JsonApiVisualizationObjectLinkageTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
} as const;

export type JsonApiVisualizationObjectLinkageTypeEnum =
    typeof JsonApiVisualizationObjectLinkageTypeEnum[keyof typeof JsonApiVisualizationObjectLinkageTypeEnum];

/**
 * JSON:API representation of visualizationObject entity.
 * @export
 * @interface JsonApiVisualizationObjectOut
 */
export interface JsonApiVisualizationObjectOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiVisualizationObjectOut
     */
    type: JsonApiVisualizationObjectOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiVisualizationObjectOut
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiVisualizationObjectOut
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
    /**
     *
     * @type {JsonApiVisualizationObjectOutRelationships}
     * @memberof JsonApiVisualizationObjectOut
     */
    relationships?: JsonApiVisualizationObjectOutRelationships;
}

export const JsonApiVisualizationObjectOutTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
} as const;

export type JsonApiVisualizationObjectOutTypeEnum =
    typeof JsonApiVisualizationObjectOutTypeEnum[keyof typeof JsonApiVisualizationObjectOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiVisualizationObjectOutDocument
 */
export interface JsonApiVisualizationObjectOutDocument {
    /**
     *
     * @type {JsonApiVisualizationObjectOut}
     * @memberof JsonApiVisualizationObjectOutDocument
     */
    data: JsonApiVisualizationObjectOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiVisualizationObjectOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiVisualizationObjectOutIncludes>}
     * @memberof JsonApiVisualizationObjectOutDocument
     */
    included?: Array<JsonApiVisualizationObjectOutIncludes>;
}
/**
 * @type JsonApiVisualizationObjectOutIncludes
 * @export
 */
export type JsonApiVisualizationObjectOutIncludes =
    | JsonApiAttributeOutWithLinks
    | JsonApiDatasetOutWithLinks
    | JsonApiFactOutWithLinks
    | JsonApiLabelOutWithLinks
    | JsonApiMetricOutWithLinks;

/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiVisualizationObjectOutList
 */
export interface JsonApiVisualizationObjectOutList {
    /**
     *
     * @type {Array<JsonApiVisualizationObjectOutWithLinks>}
     * @memberof JsonApiVisualizationObjectOutList
     */
    data: Array<JsonApiVisualizationObjectOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiVisualizationObjectOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiVisualizationObjectOutIncludes>}
     * @memberof JsonApiVisualizationObjectOutList
     */
    included?: Array<JsonApiVisualizationObjectOutIncludes>;
}
/**
 *
 * @export
 * @interface JsonApiVisualizationObjectOutRelationships
 */
export interface JsonApiVisualizationObjectOutRelationships {
    /**
     *
     * @type {JsonApiMetricOutRelationshipsFacts}
     * @memberof JsonApiVisualizationObjectOutRelationships
     */
    facts?: JsonApiMetricOutRelationshipsFacts;
    /**
     *
     * @type {JsonApiFilterContextOutRelationshipsAttributes}
     * @memberof JsonApiVisualizationObjectOutRelationships
     */
    attributes?: JsonApiFilterContextOutRelationshipsAttributes;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsLabels}
     * @memberof JsonApiVisualizationObjectOutRelationships
     */
    labels?: JsonApiAnalyticalDashboardOutRelationshipsLabels;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsMetrics}
     * @memberof JsonApiVisualizationObjectOutRelationships
     */
    metrics?: JsonApiAnalyticalDashboardOutRelationshipsMetrics;
    /**
     *
     * @type {JsonApiAnalyticalDashboardOutRelationshipsDatasets}
     * @memberof JsonApiVisualizationObjectOutRelationships
     */
    datasets?: JsonApiAnalyticalDashboardOutRelationshipsDatasets;
}
/**
 *
 * @export
 * @interface JsonApiVisualizationObjectOutWithLinks
 */
export interface JsonApiVisualizationObjectOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiVisualizationObjectOutWithLinks
     */
    type: JsonApiVisualizationObjectOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiVisualizationObjectOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiVisualizationObjectOutWithLinks
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
    /**
     *
     * @type {JsonApiVisualizationObjectOutRelationships}
     * @memberof JsonApiVisualizationObjectOutWithLinks
     */
    relationships?: JsonApiVisualizationObjectOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiVisualizationObjectOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiVisualizationObjectOutWithLinksTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
} as const;

export type JsonApiVisualizationObjectOutWithLinksTypeEnum =
    typeof JsonApiVisualizationObjectOutWithLinksTypeEnum[keyof typeof JsonApiVisualizationObjectOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching visualizationObject entity.
 * @export
 * @interface JsonApiVisualizationObjectPatch
 */
export interface JsonApiVisualizationObjectPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiVisualizationObjectPatch
     */
    type: JsonApiVisualizationObjectPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiVisualizationObjectPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiAnalyticalDashboardPatchAttributes}
     * @memberof JsonApiVisualizationObjectPatch
     */
    attributes?: JsonApiAnalyticalDashboardPatchAttributes;
}

export const JsonApiVisualizationObjectPatchTypeEnum = {
    VISUALIZATION_OBJECT: "visualizationObject",
} as const;

export type JsonApiVisualizationObjectPatchTypeEnum =
    typeof JsonApiVisualizationObjectPatchTypeEnum[keyof typeof JsonApiVisualizationObjectPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiVisualizationObjectPatchDocument
 */
export interface JsonApiVisualizationObjectPatchDocument {
    /**
     *
     * @type {JsonApiVisualizationObjectPatch}
     * @memberof JsonApiVisualizationObjectPatchDocument
     */
    data: JsonApiVisualizationObjectPatch;
}
/**
 * JSON:API representation of workspaceDataFilter entity.
 * @export
 * @interface JsonApiWorkspaceDataFilterIn
 */
export interface JsonApiWorkspaceDataFilterIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterIn
     */
    type: JsonApiWorkspaceDataFilterInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterIn
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchAttributes}
     * @memberof JsonApiWorkspaceDataFilterIn
     */
    attributes?: JsonApiWorkspaceDataFilterPatchAttributes;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchRelationships}
     * @memberof JsonApiWorkspaceDataFilterIn
     */
    relationships?: JsonApiWorkspaceDataFilterPatchRelationships;
}

export const JsonApiWorkspaceDataFilterInTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
} as const;

export type JsonApiWorkspaceDataFilterInTypeEnum =
    typeof JsonApiWorkspaceDataFilterInTypeEnum[keyof typeof JsonApiWorkspaceDataFilterInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterInDocument
 */
export interface JsonApiWorkspaceDataFilterInDocument {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterIn}
     * @memberof JsonApiWorkspaceDataFilterInDocument
     */
    data: JsonApiWorkspaceDataFilterIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiWorkspaceDataFilterLinkage
 */
export interface JsonApiWorkspaceDataFilterLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterLinkage
     */
    type: JsonApiWorkspaceDataFilterLinkageTypeEnum;
}

export const JsonApiWorkspaceDataFilterLinkageTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
} as const;

export type JsonApiWorkspaceDataFilterLinkageTypeEnum =
    typeof JsonApiWorkspaceDataFilterLinkageTypeEnum[keyof typeof JsonApiWorkspaceDataFilterLinkageTypeEnum];

/**
 * JSON:API representation of workspaceDataFilter entity.
 * @export
 * @interface JsonApiWorkspaceDataFilterOut
 */
export interface JsonApiWorkspaceDataFilterOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterOut
     */
    type: JsonApiWorkspaceDataFilterOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterOut
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchAttributes}
     * @memberof JsonApiWorkspaceDataFilterOut
     */
    attributes?: JsonApiWorkspaceDataFilterPatchAttributes;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchRelationships}
     * @memberof JsonApiWorkspaceDataFilterOut
     */
    relationships?: JsonApiWorkspaceDataFilterPatchRelationships;
}

export const JsonApiWorkspaceDataFilterOutTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
} as const;

export type JsonApiWorkspaceDataFilterOutTypeEnum =
    typeof JsonApiWorkspaceDataFilterOutTypeEnum[keyof typeof JsonApiWorkspaceDataFilterOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterOutDocument
 */
export interface JsonApiWorkspaceDataFilterOutDocument {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterOut}
     * @memberof JsonApiWorkspaceDataFilterOutDocument
     */
    data: JsonApiWorkspaceDataFilterOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiWorkspaceDataFilterOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiWorkspaceDataFilterSettingOutWithLinks>}
     * @memberof JsonApiWorkspaceDataFilterOutDocument
     */
    included?: Array<JsonApiWorkspaceDataFilterSettingOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiWorkspaceDataFilterOutList
 */
export interface JsonApiWorkspaceDataFilterOutList {
    /**
     *
     * @type {Array<JsonApiWorkspaceDataFilterOutWithLinks>}
     * @memberof JsonApiWorkspaceDataFilterOutList
     */
    data: Array<JsonApiWorkspaceDataFilterOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiWorkspaceDataFilterOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiWorkspaceDataFilterSettingOutWithLinks>}
     * @memberof JsonApiWorkspaceDataFilterOutList
     */
    included?: Array<JsonApiWorkspaceDataFilterSettingOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterOutWithLinks
 */
export interface JsonApiWorkspaceDataFilterOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterOutWithLinks
     */
    type: JsonApiWorkspaceDataFilterOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchAttributes}
     * @memberof JsonApiWorkspaceDataFilterOutWithLinks
     */
    attributes?: JsonApiWorkspaceDataFilterPatchAttributes;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchRelationships}
     * @memberof JsonApiWorkspaceDataFilterOutWithLinks
     */
    relationships?: JsonApiWorkspaceDataFilterPatchRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiWorkspaceDataFilterOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiWorkspaceDataFilterOutWithLinksTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
} as const;

export type JsonApiWorkspaceDataFilterOutWithLinksTypeEnum =
    typeof JsonApiWorkspaceDataFilterOutWithLinksTypeEnum[keyof typeof JsonApiWorkspaceDataFilterOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching workspaceDataFilter entity.
 * @export
 * @interface JsonApiWorkspaceDataFilterPatch
 */
export interface JsonApiWorkspaceDataFilterPatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterPatch
     */
    type: JsonApiWorkspaceDataFilterPatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterPatch
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchAttributes}
     * @memberof JsonApiWorkspaceDataFilterPatch
     */
    attributes?: JsonApiWorkspaceDataFilterPatchAttributes;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchRelationships}
     * @memberof JsonApiWorkspaceDataFilterPatch
     */
    relationships?: JsonApiWorkspaceDataFilterPatchRelationships;
}

export const JsonApiWorkspaceDataFilterPatchTypeEnum = {
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
} as const;

export type JsonApiWorkspaceDataFilterPatchTypeEnum =
    typeof JsonApiWorkspaceDataFilterPatchTypeEnum[keyof typeof JsonApiWorkspaceDataFilterPatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterPatchAttributes
 */
export interface JsonApiWorkspaceDataFilterPatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterPatchAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterPatchAttributes
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterPatchAttributes
     */
    columnName?: string;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterPatchDocument
 */
export interface JsonApiWorkspaceDataFilterPatchDocument {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatch}
     * @memberof JsonApiWorkspaceDataFilterPatchDocument
     */
    data: JsonApiWorkspaceDataFilterPatch;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterPatchRelationships
 */
export interface JsonApiWorkspaceDataFilterPatchRelationships {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterPatchRelationshipsFilterSettings}
     * @memberof JsonApiWorkspaceDataFilterPatchRelationships
     */
    filterSettings?: JsonApiWorkspaceDataFilterPatchRelationshipsFilterSettings;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterPatchRelationshipsFilterSettings
 */
export interface JsonApiWorkspaceDataFilterPatchRelationshipsFilterSettings {
    /**
     * References to other resource objects in a to-many (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
     * @type {Array<JsonApiWorkspaceDataFilterSettingLinkage>}
     * @memberof JsonApiWorkspaceDataFilterPatchRelationshipsFilterSettings
     */
    data: Array<JsonApiWorkspaceDataFilterSettingLinkage>;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingLinkage
 */
export interface JsonApiWorkspaceDataFilterSettingLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingLinkage
     */
    type: JsonApiWorkspaceDataFilterSettingLinkageTypeEnum;
}

export const JsonApiWorkspaceDataFilterSettingLinkageTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
} as const;

export type JsonApiWorkspaceDataFilterSettingLinkageTypeEnum =
    typeof JsonApiWorkspaceDataFilterSettingLinkageTypeEnum[keyof typeof JsonApiWorkspaceDataFilterSettingLinkageTypeEnum];

/**
 * JSON:API representation of workspaceDataFilterSetting entity.
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOut
 */
export interface JsonApiWorkspaceDataFilterSettingOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingOut
     */
    type: JsonApiWorkspaceDataFilterSettingOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingOut
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterSettingOutAttributes}
     * @memberof JsonApiWorkspaceDataFilterSettingOut
     */
    attributes?: JsonApiWorkspaceDataFilterSettingOutAttributes;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterSettingOutRelationships}
     * @memberof JsonApiWorkspaceDataFilterSettingOut
     */
    relationships?: JsonApiWorkspaceDataFilterSettingOutRelationships;
}

export const JsonApiWorkspaceDataFilterSettingOutTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
} as const;

export type JsonApiWorkspaceDataFilterSettingOutTypeEnum =
    typeof JsonApiWorkspaceDataFilterSettingOutTypeEnum[keyof typeof JsonApiWorkspaceDataFilterSettingOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOutAttributes
 */
export interface JsonApiWorkspaceDataFilterSettingOutAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingOutAttributes
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingOutAttributes
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof JsonApiWorkspaceDataFilterSettingOutAttributes
     */
    filterValues?: Array<string>;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOutDocument
 */
export interface JsonApiWorkspaceDataFilterSettingOutDocument {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterSettingOut}
     * @memberof JsonApiWorkspaceDataFilterSettingOutDocument
     */
    data: JsonApiWorkspaceDataFilterSettingOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiWorkspaceDataFilterSettingOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiWorkspaceDataFilterOutWithLinks>}
     * @memberof JsonApiWorkspaceDataFilterSettingOutDocument
     */
    included?: Array<JsonApiWorkspaceDataFilterOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOutList
 */
export interface JsonApiWorkspaceDataFilterSettingOutList {
    /**
     *
     * @type {Array<JsonApiWorkspaceDataFilterSettingOutWithLinks>}
     * @memberof JsonApiWorkspaceDataFilterSettingOutList
     */
    data: Array<JsonApiWorkspaceDataFilterSettingOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiWorkspaceDataFilterSettingOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiWorkspaceDataFilterOutWithLinks>}
     * @memberof JsonApiWorkspaceDataFilterSettingOutList
     */
    included?: Array<JsonApiWorkspaceDataFilterOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOutRelationships
 */
export interface JsonApiWorkspaceDataFilterSettingOutRelationships {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterSettingOutRelationshipsWorkspaceDataFilter}
     * @memberof JsonApiWorkspaceDataFilterSettingOutRelationships
     */
    workspaceDataFilter?: JsonApiWorkspaceDataFilterSettingOutRelationshipsWorkspaceDataFilter;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOutRelationshipsWorkspaceDataFilter
 */
export interface JsonApiWorkspaceDataFilterSettingOutRelationshipsWorkspaceDataFilter {
    /**
     *
     * @type {JsonApiWorkspaceDataFilterToOneLinkage}
     * @memberof JsonApiWorkspaceDataFilterSettingOutRelationshipsWorkspaceDataFilter
     */
    data: JsonApiWorkspaceDataFilterToOneLinkage | null;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceDataFilterSettingOutWithLinks
 */
export interface JsonApiWorkspaceDataFilterSettingOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingOutWithLinks
     */
    type: JsonApiWorkspaceDataFilterSettingOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceDataFilterSettingOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterSettingOutAttributes}
     * @memberof JsonApiWorkspaceDataFilterSettingOutWithLinks
     */
    attributes?: JsonApiWorkspaceDataFilterSettingOutAttributes;
    /**
     *
     * @type {JsonApiWorkspaceDataFilterSettingOutRelationships}
     * @memberof JsonApiWorkspaceDataFilterSettingOutWithLinks
     */
    relationships?: JsonApiWorkspaceDataFilterSettingOutRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiWorkspaceDataFilterSettingOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiWorkspaceDataFilterSettingOutWithLinksTypeEnum = {
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
} as const;

export type JsonApiWorkspaceDataFilterSettingOutWithLinksTypeEnum =
    typeof JsonApiWorkspaceDataFilterSettingOutWithLinksTypeEnum[keyof typeof JsonApiWorkspaceDataFilterSettingOutWithLinksTypeEnum];

/**
 * @type JsonApiWorkspaceDataFilterToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiWorkspaceDataFilterToOneLinkage = JsonApiWorkspaceDataFilterLinkage;

/**
 * JSON:API representation of workspace entity.
 * @export
 * @interface JsonApiWorkspaceIn
 */
export interface JsonApiWorkspaceIn {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceIn
     */
    type: JsonApiWorkspaceInTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceIn
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspacePatchAttributes}
     * @memberof JsonApiWorkspaceIn
     */
    attributes?: JsonApiWorkspacePatchAttributes;
    /**
     *
     * @type {JsonApiWorkspacePatchRelationships}
     * @memberof JsonApiWorkspaceIn
     */
    relationships?: JsonApiWorkspacePatchRelationships;
}

export const JsonApiWorkspaceInTypeEnum = {
    WORKSPACE: "workspace",
} as const;

export type JsonApiWorkspaceInTypeEnum =
    typeof JsonApiWorkspaceInTypeEnum[keyof typeof JsonApiWorkspaceInTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceInDocument
 */
export interface JsonApiWorkspaceInDocument {
    /**
     *
     * @type {JsonApiWorkspaceIn}
     * @memberof JsonApiWorkspaceInDocument
     */
    data: JsonApiWorkspaceIn;
}
/**
 * The \\\"type\\\" and \\\"id\\\" to non-empty members.
 * @export
 * @interface JsonApiWorkspaceLinkage
 */
export interface JsonApiWorkspaceLinkage {
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceLinkage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspaceLinkage
     */
    type: JsonApiWorkspaceLinkageTypeEnum;
}

export const JsonApiWorkspaceLinkageTypeEnum = {
    WORKSPACE: "workspace",
} as const;

export type JsonApiWorkspaceLinkageTypeEnum =
    typeof JsonApiWorkspaceLinkageTypeEnum[keyof typeof JsonApiWorkspaceLinkageTypeEnum];

/**
 * JSON:API representation of workspace entity.
 * @export
 * @interface JsonApiWorkspaceOut
 */
export interface JsonApiWorkspaceOut {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceOut
     */
    type: JsonApiWorkspaceOutTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceOut
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceOutMeta}
     * @memberof JsonApiWorkspaceOut
     */
    meta?: JsonApiWorkspaceOutMeta;
    /**
     *
     * @type {JsonApiWorkspacePatchAttributes}
     * @memberof JsonApiWorkspaceOut
     */
    attributes?: JsonApiWorkspacePatchAttributes;
    /**
     *
     * @type {JsonApiWorkspacePatchRelationships}
     * @memberof JsonApiWorkspaceOut
     */
    relationships?: JsonApiWorkspacePatchRelationships;
}

export const JsonApiWorkspaceOutTypeEnum = {
    WORKSPACE: "workspace",
} as const;

export type JsonApiWorkspaceOutTypeEnum =
    typeof JsonApiWorkspaceOutTypeEnum[keyof typeof JsonApiWorkspaceOutTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceOutDocument
 */
export interface JsonApiWorkspaceOutDocument {
    /**
     *
     * @type {JsonApiWorkspaceOut}
     * @memberof JsonApiWorkspaceOutDocument
     */
    data: JsonApiWorkspaceOut;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiWorkspaceOutDocument
     */
    links?: ObjectLinks;
    /**
     * Included resources
     * @type {Array<JsonApiWorkspaceOutWithLinks>}
     * @memberof JsonApiWorkspaceOutDocument
     */
    included?: Array<JsonApiWorkspaceOutWithLinks>;
}
/**
 * A JSON:API document with a list of resources
 * @export
 * @interface JsonApiWorkspaceOutList
 */
export interface JsonApiWorkspaceOutList {
    /**
     *
     * @type {Array<JsonApiWorkspaceOutWithLinks>}
     * @memberof JsonApiWorkspaceOutList
     */
    data: Array<JsonApiWorkspaceOutWithLinks>;
    /**
     *
     * @type {ListLinks}
     * @memberof JsonApiWorkspaceOutList
     */
    links?: ListLinks;
    /**
     * Included resources
     * @type {Array<JsonApiWorkspaceOutWithLinks>}
     * @memberof JsonApiWorkspaceOutList
     */
    included?: Array<JsonApiWorkspaceOutWithLinks>;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceOutMeta
 */
export interface JsonApiWorkspaceOutMeta {
    /**
     *
     * @type {JsonApiWorkspaceOutMetaConfig}
     * @memberof JsonApiWorkspaceOutMeta
     */
    config?: JsonApiWorkspaceOutMetaConfig;
    /**
     * List of valid permissions for a logged user.
     * @type {Array<string>}
     * @memberof JsonApiWorkspaceOutMeta
     */
    permissions?: Array<JsonApiWorkspaceOutMetaPermissionsEnum>;
}

export const JsonApiWorkspaceOutMetaPermissionsEnum = {
    MANAGE: "MANAGE",
    ANALYZE: "ANALYZE",
    VIEW: "VIEW",
} as const;

export type JsonApiWorkspaceOutMetaPermissionsEnum =
    typeof JsonApiWorkspaceOutMetaPermissionsEnum[keyof typeof JsonApiWorkspaceOutMetaPermissionsEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspaceOutMetaConfig
 */
export interface JsonApiWorkspaceOutMetaConfig {
    /**
     * is sampling enabled - based on type of data-source connected to this workspace
     * @type {boolean}
     * @memberof JsonApiWorkspaceOutMetaConfig
     */
    dataSamplingAvailable: boolean;
    /**
     * is approximate count enabled - based on type of data-source connected to this workspace
     * @type {boolean}
     * @memberof JsonApiWorkspaceOutMetaConfig
     */
    approximateCountAvailable: boolean;
}
/**
 *
 * @export
 * @interface JsonApiWorkspaceOutWithLinks
 */
export interface JsonApiWorkspaceOutWithLinks {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspaceOutWithLinks
     */
    type: JsonApiWorkspaceOutWithLinksTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspaceOutWithLinks
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspaceOutMeta}
     * @memberof JsonApiWorkspaceOutWithLinks
     */
    meta?: JsonApiWorkspaceOutMeta;
    /**
     *
     * @type {JsonApiWorkspacePatchAttributes}
     * @memberof JsonApiWorkspaceOutWithLinks
     */
    attributes?: JsonApiWorkspacePatchAttributes;
    /**
     *
     * @type {JsonApiWorkspacePatchRelationships}
     * @memberof JsonApiWorkspaceOutWithLinks
     */
    relationships?: JsonApiWorkspacePatchRelationships;
    /**
     *
     * @type {ObjectLinks}
     * @memberof JsonApiWorkspaceOutWithLinks
     */
    links?: ObjectLinks;
}

export const JsonApiWorkspaceOutWithLinksTypeEnum = {
    WORKSPACE: "workspace",
} as const;

export type JsonApiWorkspaceOutWithLinksTypeEnum =
    typeof JsonApiWorkspaceOutWithLinksTypeEnum[keyof typeof JsonApiWorkspaceOutWithLinksTypeEnum];

/**
 * JSON:API representation of patching workspace entity.
 * @export
 * @interface JsonApiWorkspacePatch
 */
export interface JsonApiWorkspacePatch {
    /**
     * Object type
     * @type {string}
     * @memberof JsonApiWorkspacePatch
     */
    type: JsonApiWorkspacePatchTypeEnum;
    /**
     * API identifier of an object
     * @type {string}
     * @memberof JsonApiWorkspacePatch
     */
    id: string;
    /**
     *
     * @type {JsonApiWorkspacePatchAttributes}
     * @memberof JsonApiWorkspacePatch
     */
    attributes?: JsonApiWorkspacePatchAttributes;
    /**
     *
     * @type {JsonApiWorkspacePatchRelationships}
     * @memberof JsonApiWorkspacePatch
     */
    relationships?: JsonApiWorkspacePatchRelationships;
}

export const JsonApiWorkspacePatchTypeEnum = {
    WORKSPACE: "workspace",
} as const;

export type JsonApiWorkspacePatchTypeEnum =
    typeof JsonApiWorkspacePatchTypeEnum[keyof typeof JsonApiWorkspacePatchTypeEnum];

/**
 *
 * @export
 * @interface JsonApiWorkspacePatchAttributes
 */
export interface JsonApiWorkspacePatchAttributes {
    /**
     *
     * @type {string}
     * @memberof JsonApiWorkspacePatchAttributes
     */
    name?: string;
}
/**
 *
 * @export
 * @interface JsonApiWorkspacePatchDocument
 */
export interface JsonApiWorkspacePatchDocument {
    /**
     *
     * @type {JsonApiWorkspacePatch}
     * @memberof JsonApiWorkspacePatchDocument
     */
    data: JsonApiWorkspacePatch;
}
/**
 *
 * @export
 * @interface JsonApiWorkspacePatchRelationships
 */
export interface JsonApiWorkspacePatchRelationships {
    /**
     *
     * @type {JsonApiWorkspacePatchRelationshipsParent}
     * @memberof JsonApiWorkspacePatchRelationships
     */
    parent?: JsonApiWorkspacePatchRelationshipsParent;
}
/**
 *
 * @export
 * @interface JsonApiWorkspacePatchRelationshipsParent
 */
export interface JsonApiWorkspacePatchRelationshipsParent {
    /**
     *
     * @type {JsonApiWorkspaceToOneLinkage}
     * @memberof JsonApiWorkspacePatchRelationshipsParent
     */
    data: JsonApiWorkspaceToOneLinkage | null;
}
/**
 * @type JsonApiWorkspaceToOneLinkage
 * References to other resource objects in a to-one (\\\"relationship\\\"). Relationships can be specified by including a member in a resource\'s links object.
 * @export
 */
export type JsonApiWorkspaceToOneLinkage = JsonApiWorkspaceLinkage;

/**
 * A label identifier.
 * @export
 * @interface LabelIdentifier
 */
export interface LabelIdentifier {
    /**
     * Label ID.
     * @type {string}
     * @memberof LabelIdentifier
     */
    id: string;
    /**
     * A type of the label.
     * @type {string}
     * @memberof LabelIdentifier
     */
    type: LabelIdentifierTypeEnum;
}

export const LabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type LabelIdentifierTypeEnum = typeof LabelIdentifierTypeEnum[keyof typeof LabelIdentifierTypeEnum];

/**
 *
 * @export
 * @interface ListLinks
 */
export interface ListLinks {
    /**
     * A string containing the link\'s URL.
     * @type {string}
     * @memberof ListLinks
     */
    self: string;
    /**
     * A string containing the link\'s URL for the next page of data.
     * @type {string}
     * @memberof ListLinks
     */
    next?: string;
}
/**
 *
 * @export
 * @interface ListLinksAllOf
 */
export interface ListLinksAllOf {
    /**
     * A string containing the link\'s URL for the next page of data.
     * @type {string}
     * @memberof ListLinksAllOf
     */
    next?: string;
}
/**
 *
 * @export
 * @interface ObjectLinks
 */
export interface ObjectLinks {
    /**
     * A string containing the link\'s URL.
     * @type {string}
     * @memberof ObjectLinks
     */
    self: string;
}
/**
 *
 * @export
 * @interface ObjectLinksContainer
 */
export interface ObjectLinksContainer {
    /**
     *
     * @type {ObjectLinks}
     * @memberof ObjectLinksContainer
     */
    links?: ObjectLinks;
}
/**
 * A reference identifier.
 * @export
 * @interface ReferenceIdentifier
 */
export interface ReferenceIdentifier {
    /**
     * Reference ID.
     * @type {string}
     * @memberof ReferenceIdentifier
     */
    id: string;
    /**
     * A type of the reference.
     * @type {string}
     * @memberof ReferenceIdentifier
     */
    type: ReferenceIdentifierTypeEnum;
}

export const ReferenceIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type ReferenceIdentifierTypeEnum =
    typeof ReferenceIdentifierTypeEnum[keyof typeof ReferenceIdentifierTypeEnum];

/**
 * A user group identifier.
 * @export
 * @interface UserGroupIdentifier
 */
export interface UserGroupIdentifier {
    /**
     * Identifier of the user group.
     * @type {string}
     * @memberof UserGroupIdentifier
     */
    id: string;
    /**
     * A type.
     * @type {string}
     * @memberof UserGroupIdentifier
     */
    type: UserGroupIdentifierTypeEnum;
}

export const UserGroupIdentifierTypeEnum = {
    USER_GROUP: "userGroup",
} as const;

export type UserGroupIdentifierTypeEnum =
    typeof UserGroupIdentifierTypeEnum[keyof typeof UserGroupIdentifierTypeEnum];

/**
 * A workspace identifier.
 * @export
 * @interface WorkspaceIdentifier
 */
export interface WorkspaceIdentifier {
    /**
     * Identifier of the workspace.
     * @type {string}
     * @memberof WorkspaceIdentifier
     */
    id: string;
    /**
     * A type.
     * @type {string}
     * @memberof WorkspaceIdentifier
     */
    type: WorkspaceIdentifierTypeEnum;
}

export const WorkspaceIdentifierTypeEnum = {
    WORKSPACE: "workspace",
} as const;

export type WorkspaceIdentifierTypeEnum =
    typeof WorkspaceIdentifierTypeEnum[keyof typeof WorkspaceIdentifierTypeEnum];

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate LDM from PDM stored in data source.
         * @summary Generate LDM from PDM
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel(
            params: {
                dataSourceId: string;
                generateLdmRequest: GenerateLdmRequest;
            },
            options: any = {},
        ): RequestArgs {
            const { dataSourceId, generateLdmRequest } = params;
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("generateLogicalModel", "dataSourceId", dataSourceId);
            // verify required parameter 'generateLdmRequest' is not null or undefined
            assertParamExists("generateLogicalModel", "generateLdmRequest", generateLdmRequest);
            const localVarPath = `/api/actions/dataSources/{dataSourceId}/generateLogicalModel`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof generateLdmRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(generateLdmRequest !== undefined ? generateLdmRequest : {})
                : generateLdmRequest || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification(
            params: {
                dataSourceId: string;
            },
            options: any = {},
        ): RequestArgs {
            const { dataSourceId } = params;
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("registerUploadNotification", "dataSourceId", dataSourceId);
            const localVarPath = `/api/actions/dataSources/{dataSourceId}/uploadNotification`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Generate LDM from PDM stored in data source.
         * @summary Generate LDM from PDM
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel(
            params: {
                dataSourceId: string;
                generateLdmRequest: GenerateLdmRequest;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeModel> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).generateLogicalModel(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification(
            params: {
                dataSourceId: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).registerUploadNotification(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Generate LDM from PDM stored in data source.
         * @summary Generate LDM from PDM
         * @param {string} dataSourceId
         * @param {GenerateLdmRequest} generateLdmRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateLogicalModel(
            params: {
                dataSourceId: string;
                generateLdmRequest: GenerateLdmRequest;
            },
            options?: any,
        ): AxiosPromise<DeclarativeModel> {
            return ActionsApiFp(configuration).generateLogicalModel(params, options)(axios, basePath);
        },
        /**
         * Notification sets up all reports to be computed again with new data.
         * @summary Register an upload notification
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUploadNotification(
            params: {
                dataSourceId: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return ActionsApiFp(configuration).registerUploadNotification(params, options)(axios, basePath);
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Generate LDM from PDM stored in data source.
     * @summary Generate LDM from PDM
     * @param {string} dataSourceId
     * @param {GenerateLdmRequest} generateLdmRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    generateLogicalModel(
        params: {
            dataSourceId: string;
            generateLdmRequest: GenerateLdmRequest;
        },
        options?: any,
    ): AxiosPromise<DeclarativeModel>;

    /**
     * Notification sets up all reports to be computed again with new data.
     * @summary Register an upload notification
     * @param {string} dataSourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    registerUploadNotification(
        params: {
            dataSourceId: string;
        },
        options?: any,
    ): AxiosPromise<void>;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Generate LDM from PDM stored in data source.
     * @summary Generate LDM from PDM
     * @param {string} dataSourceId
     * @param {GenerateLdmRequest} generateLdmRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public generateLogicalModel(
        params: {
            dataSourceId: string;
            generateLdmRequest: GenerateLdmRequest;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).generateLogicalModel(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Notification sets up all reports to be computed again with new data.
     * @summary Register an upload notification
     * @param {string} dataSourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public registerUploadNotification(
        params: {
            dataSourceId: string;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).registerUploadNotification(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * EntitiesApi - axios parameter creator
 * @export
 */
export const EntitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, jsonApiAnalyticalDashboardInDocument, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiAnalyticalDashboardInDocument' is not null or undefined
            assertParamExists(
                "createEntityAnalyticalDashboards",
                "jsonApiAnalyticalDashboardInDocument",
                jsonApiAnalyticalDashboardInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiAnalyticalDashboardInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiAnalyticalDashboardInDocument !== undefined
                          ? jsonApiAnalyticalDashboardInDocument
                          : {},
                  )
                : jsonApiAnalyticalDashboardInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens(
            params: {
                userId: string;
                jsonApiApiTokenInDocument: JsonApiApiTokenInDocument;
            },
            options: any = {},
        ): RequestArgs {
            const { userId, jsonApiApiTokenInDocument } = params;
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("createEntityApiTokens", "userId", userId);
            // verify required parameter 'jsonApiApiTokenInDocument' is not null or undefined
            assertParamExists(
                "createEntityApiTokens",
                "jsonApiApiTokenInDocument",
                jsonApiApiTokenInDocument,
            );
            const localVarPath = `/api/entities/users/{userId}/apiTokens`.replace(
                `{${"userId"}}`,
                encodeURIComponent(String(userId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiApiTokenInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiApiTokenInDocument !== undefined ? jsonApiApiTokenInDocument : {})
                : jsonApiApiTokenInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins(
            params: {
                workspaceId: string;
                jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, jsonApiDashboardPluginInDocument } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiDashboardPluginInDocument' is not null or undefined
            assertParamExists(
                "createEntityDashboardPlugins",
                "jsonApiDashboardPluginInDocument",
                jsonApiDashboardPluginInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiDashboardPluginInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiDashboardPluginInDocument !== undefined ? jsonApiDashboardPluginInDocument : {},
                  )
                : jsonApiDashboardPluginInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources(
            params: {
                jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
            },
            options: any = {},
        ): RequestArgs {
            const { jsonApiDataSourceInDocument } = params;
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists(
                "createEntityDataSources",
                "jsonApiDataSourceInDocument",
                jsonApiDataSourceInDocument,
            );
            const localVarPath = `/api/entities/dataSources`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts(
            params: {
                workspaceId: string;
                jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, jsonApiFilterContextInDocument, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiFilterContextInDocument' is not null or undefined
            assertParamExists(
                "createEntityFilterContexts",
                "jsonApiFilterContextInDocument",
                jsonApiFilterContextInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/filterContexts`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiFilterContextInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiFilterContextInDocument !== undefined ? jsonApiFilterContextInDocument : {},
                  )
                : jsonApiFilterContextInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics(
            params: {
                workspaceId: string;
                jsonApiMetricInDocument: JsonApiMetricInDocument;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, jsonApiMetricInDocument, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiMetricInDocument' is not null or undefined
            assertParamExists("createEntityMetrics", "jsonApiMetricInDocument", jsonApiMetricInDocument);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/metrics`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiMetricInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricInDocument !== undefined ? jsonApiMetricInDocument : {})
                : jsonApiMetricInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups(
            params: {
                jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { jsonApiUserGroupInDocument, include } = params;
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists(
                "createEntityUserGroups",
                "jsonApiUserGroupInDocument",
                jsonApiUserGroupInDocument,
            );
            const localVarPath = `/api/entities/userGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers(
            params: {
                jsonApiUserInDocument: JsonApiUserInDocument;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { jsonApiUserInDocument, include } = params;
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("createEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/entities/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects(
            params: {
                workspaceId: string;
                jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, jsonApiVisualizationObjectInDocument, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiVisualizationObjectInDocument' is not null or undefined
            assertParamExists(
                "createEntityVisualizationObjects",
                "jsonApiVisualizationObjectInDocument",
                jsonApiVisualizationObjectInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/visualizationObjects`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiVisualizationObjectInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiVisualizationObjectInDocument !== undefined
                          ? jsonApiVisualizationObjectInDocument
                          : {},
                  )
                : jsonApiVisualizationObjectInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, jsonApiWorkspaceDataFilterInDocument, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists(
                "createEntityWorkspaceDataFilters",
                "jsonApiWorkspaceDataFilterInDocument",
                jsonApiWorkspaceDataFilterInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiWorkspaceDataFilterInDocument !== undefined
                          ? jsonApiWorkspaceDataFilterInDocument
                          : {},
                  )
                : jsonApiWorkspaceDataFilterInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces(
            params: {
                jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { jsonApiWorkspaceInDocument, include } = params;
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists(
                "createEntityWorkspaces",
                "jsonApiWorkspaceInDocument",
                jsonApiWorkspaceInDocument,
            );
            const localVarPath = `/api/entities/workspaces`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens(
            params: {
                userId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { userId, id, predicate, filter } = params;
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityApiTokens", "id", id);
            const localVarPath = `/api/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityDataSources", "id", id);
            const localVarPath = `/api/entities/dataSources/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUserGroups", "id", id);
            const localVarPath = `/api/entities/userGroups/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityUsers", "id", id);
            const localVarPath = `/api/entities/users/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("deleteEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("deleteEntityWorkspaces", "id", id);
            const localVarPath = `/api/entities/workspaces/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAnalyticalDashboards", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/analyticalDashboards`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens(
            params: {
                userId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): RequestArgs {
            const { userId, predicate, filter, page, size, sort } = params;
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getAllEntitiesApiTokens", "userId", userId);
            const localVarPath = `/api/entities/users/{userId}/apiTokens`.replace(
                `{${"userId"}}`,
                encodeURIComponent(String(userId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesAttributes", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/attributes`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, page, size, sort, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDashboardPlugins", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/dashboardPlugins`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { predicate, filter, page, size, sort, metaInclude } = params;
            const localVarPath = `/api/entities/dataSourceIdentifiers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables(
            params: {
                dataSourceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): RequestArgs {
            const { dataSourceId, predicate, filter, page, size, sort } = params;
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getAllEntitiesDataSourceTables", "dataSourceId", dataSourceId);
            const localVarPath = `/api/entities/dataSources/{dataSourceId}/dataSourceTables`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { predicate, filter, page, size, sort, metaInclude } = params;
            const localVarPath = `/api/entities/dataSources`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesDatasets", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/datasets`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "dataset" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFacts", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/facts`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesFilterContexts", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/filterContexts`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "attribute" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesLabels", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/labels`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesMetrics", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/metrics`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): RequestArgs {
            const { predicate, filter, include, page, size, sort } = params;
            const localVarPath = `/api/entities/userGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): RequestArgs {
            const { predicate, filter, include, page, size, sort } = params;
            const localVarPath = `/api/entities/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesVisualizationObjects", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/visualizationObjects`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilterSettings`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, predicate, filter, include, page, size, sort, xGDCVALIDATERELATIONS } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAllEntitiesWorkspaceDataFilters", "workspaceId", workspaceId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilters`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { predicate, filter, include, page, size, sort, metaInclude } = params;
            const localVarPath = `/api/entities/workspaces`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (page !== undefined) {
                if (typeof page === "object") {
                    addFlattenedObjectTo(page, localVarQueryParameter);
                } else {
                    localVarQueryParameter["page"] = page;
                }
            }

            if (size !== undefined) {
                if (typeof size === "object") {
                    addFlattenedObjectTo(size, localVarQueryParameter);
                } else {
                    localVarQueryParameter["size"] = size;
                }
            }

            if (sort) {
                localVarQueryParameter["sort"] = sort;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/options`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/options/availableDrivers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAnalyticalDashboards", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens(
            params: {
                userId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { userId, id, predicate, filter } = params;
            // verify required parameter 'userId' is not null or undefined
            assertParamExists("getEntityApiTokens", "userId", userId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityApiTokens", "id", id);
            const localVarPath = `/api/entities/users/{userId}/apiTokens/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityAttributes", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityAttributes", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/attributes/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityCookieSecurityConfigurations", "id", id);
            const localVarPath = `/api/entities/admin/cookieSecurityConfigurations/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDashboardPlugins", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter, metaInclude } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceIdentifiers", "id", id);
            const localVarPath = `/api/entities/dataSourceIdentifiers/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables(
            params: {
                dataSourceId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { dataSourceId, id, predicate, filter } = params;
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "dataSourceId", dataSourceId);
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSourceTables", "id", id);
            const localVarPath = `/api/entities/dataSources/{dataSourceId}/dataSourceTables/{id}`
                .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter, metaInclude } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityDataSources", "id", id);
            const localVarPath = `/api/entities/dataSources/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityDatasets", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityDatasets", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/datasets/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "dataset" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFacts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFacts", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/facts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityFilterContexts", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "attribute" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityLabels", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityLabels", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/labels/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityMetrics", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter, include, metaInclude } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityOrganizations", "id", id);
            const localVarPath = `/api/entities/admin/organizations/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUserGroups", "id", id);
            const localVarPath = `/api/entities/userGroups/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityUsers", "id", id);
            const localVarPath = `/api/entities/users/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityVisualizationObjects", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilterSettings", "objectId", objectId);
            const localVarPath =
                `/api/entities/workspaces/{workspaceId}/workspaceDataFilterSettings/{objectId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, predicate, filter, include, xGDCVALIDATERELATIONS } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("getEntityWorkspaceDataFilters", "objectId", objectId);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (xGDCVALIDATERELATIONS !== undefined && xGDCVALIDATERELATIONS !== null) {
                localVarHeaderParameter["X-GDC-VALIDATE-RELATIONS"] = String(
                    JSON.stringify(xGDCVALIDATERELATIONS),
                );
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
                metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, predicate, filter, include, metaInclude } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("getEntityWorkspaces", "id", id);
            const localVarPath = `/api/entities/workspaces/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(
            params: {
                metaInclude?: Array<"permissions" | "all">;
            },
            options: any = {},
        ): RequestArgs {
            const { metaInclude } = params;
            const localVarPath = `/api/entities/organization`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = metaInclude.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiAnalyticalDashboardPatchDocument: JsonApiAnalyticalDashboardPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                objectId,
                jsonApiAnalyticalDashboardPatchDocument,
                predicate,
                filter,
                include,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardPatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityAnalyticalDashboards",
                "jsonApiAnalyticalDashboardPatchDocument",
                jsonApiAnalyticalDashboardPatchDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiAnalyticalDashboardPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiAnalyticalDashboardPatchDocument !== undefined
                          ? jsonApiAnalyticalDashboardPatchDocument
                          : {},
                  )
                : jsonApiAnalyticalDashboardPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiDashboardPluginPatchDocument: JsonApiDashboardPluginPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, jsonApiDashboardPluginPatchDocument, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginPatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityDashboardPlugins",
                "jsonApiDashboardPluginPatchDocument",
                jsonApiDashboardPluginPatchDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiDashboardPluginPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiDashboardPluginPatchDocument !== undefined
                          ? jsonApiDashboardPluginPatchDocument
                          : {},
                  )
                : jsonApiDashboardPluginPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources(
            params: {
                id: string;
                jsonApiDataSourcePatchDocument: JsonApiDataSourcePatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiDataSourcePatchDocument, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourcePatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityDataSources",
                "jsonApiDataSourcePatchDocument",
                jsonApiDataSourcePatchDocument,
            );
            const localVarPath = `/api/entities/dataSources/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiDataSourcePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiDataSourcePatchDocument !== undefined ? jsonApiDataSourcePatchDocument : {},
                  )
                : jsonApiDataSourcePatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiFilterContextPatchDocument: JsonApiFilterContextPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, jsonApiFilterContextPatchDocument, predicate, filter, include } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextPatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityFilterContexts",
                "jsonApiFilterContextPatchDocument",
                jsonApiFilterContextPatchDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiFilterContextPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiFilterContextPatchDocument !== undefined
                          ? jsonApiFilterContextPatchDocument
                          : {},
                  )
                : jsonApiFilterContextPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiMetricPatchDocument: JsonApiMetricPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, jsonApiMetricPatchDocument, predicate, filter, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricPatchDocument' is not null or undefined
            assertParamExists("patchEntityMetrics", "jsonApiMetricPatchDocument", jsonApiMetricPatchDocument);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiMetricPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricPatchDocument !== undefined ? jsonApiMetricPatchDocument : {})
                : jsonApiMetricPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups(
            params: {
                id: string;
                jsonApiUserGroupPatchDocument: JsonApiUserGroupPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiUserGroupPatchDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupPatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityUserGroups",
                "jsonApiUserGroupPatchDocument",
                jsonApiUserGroupPatchDocument,
            );
            const localVarPath = `/api/entities/userGroups/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiUserGroupPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiUserGroupPatchDocument !== undefined ? jsonApiUserGroupPatchDocument : {},
                  )
                : jsonApiUserGroupPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers(
            params: {
                id: string;
                jsonApiUserPatchDocument: JsonApiUserPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiUserPatchDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserPatchDocument' is not null or undefined
            assertParamExists("patchEntityUsers", "jsonApiUserPatchDocument", jsonApiUserPatchDocument);
            const localVarPath = `/api/entities/users/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiUserPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserPatchDocument !== undefined ? jsonApiUserPatchDocument : {})
                : jsonApiUserPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiVisualizationObjectPatchDocument: JsonApiVisualizationObjectPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                objectId,
                jsonApiVisualizationObjectPatchDocument,
                predicate,
                filter,
                include,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectPatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityVisualizationObjects",
                "jsonApiVisualizationObjectPatchDocument",
                jsonApiVisualizationObjectPatchDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiVisualizationObjectPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiVisualizationObjectPatchDocument !== undefined
                          ? jsonApiVisualizationObjectPatchDocument
                          : {},
                  )
                : jsonApiVisualizationObjectPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiWorkspaceDataFilterPatchDocument: JsonApiWorkspaceDataFilterPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                objectId,
                jsonApiWorkspaceDataFilterPatchDocument,
                predicate,
                filter,
                include,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("patchEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterPatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityWorkspaceDataFilters",
                "jsonApiWorkspaceDataFilterPatchDocument",
                jsonApiWorkspaceDataFilterPatchDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiWorkspaceDataFilterPatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiWorkspaceDataFilterPatchDocument !== undefined
                          ? jsonApiWorkspaceDataFilterPatchDocument
                          : {},
                  )
                : jsonApiWorkspaceDataFilterPatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces(
            params: {
                id: string;
                jsonApiWorkspacePatchDocument: JsonApiWorkspacePatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiWorkspacePatchDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("patchEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspacePatchDocument' is not null or undefined
            assertParamExists(
                "patchEntityWorkspaces",
                "jsonApiWorkspacePatchDocument",
                jsonApiWorkspacePatchDocument,
            );
            const localVarPath = `/api/entities/workspaces/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiWorkspacePatchDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiWorkspacePatchDocument !== undefined ? jsonApiWorkspacePatchDocument : {},
                  )
                : jsonApiWorkspacePatchDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                objectId,
                jsonApiAnalyticalDashboardInDocument,
                predicate,
                filter,
                include,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityAnalyticalDashboards", "objectId", objectId);
            // verify required parameter 'jsonApiAnalyticalDashboardInDocument' is not null or undefined
            assertParamExists(
                "updateEntityAnalyticalDashboards",
                "jsonApiAnalyticalDashboardInDocument",
                jsonApiAnalyticalDashboardInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/analyticalDashboards/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiAnalyticalDashboardInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiAnalyticalDashboardInDocument !== undefined
                          ? jsonApiAnalyticalDashboardInDocument
                          : {},
                  )
                : jsonApiAnalyticalDashboardInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations(
            params: {
                id: string;
                jsonApiCookieSecurityConfigurationInDocument: JsonApiCookieSecurityConfigurationInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiCookieSecurityConfigurationInDocument, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityCookieSecurityConfigurations", "id", id);
            // verify required parameter 'jsonApiCookieSecurityConfigurationInDocument' is not null or undefined
            assertParamExists(
                "updateEntityCookieSecurityConfigurations",
                "jsonApiCookieSecurityConfigurationInDocument",
                jsonApiCookieSecurityConfigurationInDocument,
            );
            const localVarPath = `/api/entities/admin/cookieSecurityConfigurations/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiCookieSecurityConfigurationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiCookieSecurityConfigurationInDocument !== undefined
                          ? jsonApiCookieSecurityConfigurationInDocument
                          : {},
                  )
                : jsonApiCookieSecurityConfigurationInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, jsonApiDashboardPluginInDocument, predicate, filter } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityDashboardPlugins", "objectId", objectId);
            // verify required parameter 'jsonApiDashboardPluginInDocument' is not null or undefined
            assertParamExists(
                "updateEntityDashboardPlugins",
                "jsonApiDashboardPluginInDocument",
                jsonApiDashboardPluginInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/dashboardPlugins/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiDashboardPluginInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiDashboardPluginInDocument !== undefined ? jsonApiDashboardPluginInDocument : {},
                  )
                : jsonApiDashboardPluginInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources(
            params: {
                id: string;
                jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiDataSourceInDocument, predicate, filter } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityDataSources", "id", id);
            // verify required parameter 'jsonApiDataSourceInDocument' is not null or undefined
            assertParamExists(
                "updateEntityDataSources",
                "jsonApiDataSourceInDocument",
                jsonApiDataSourceInDocument,
            );
            const localVarPath = `/api/entities/dataSources/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiDataSourceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiDataSourceInDocument !== undefined ? jsonApiDataSourceInDocument : {})
                : jsonApiDataSourceInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, jsonApiFilterContextInDocument, predicate, filter, include } =
                params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityFilterContexts", "objectId", objectId);
            // verify required parameter 'jsonApiFilterContextInDocument' is not null or undefined
            assertParamExists(
                "updateEntityFilterContexts",
                "jsonApiFilterContextInDocument",
                jsonApiFilterContextInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/filterContexts/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiFilterContextInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiFilterContextInDocument !== undefined ? jsonApiFilterContextInDocument : {},
                  )
                : jsonApiFilterContextInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiMetricInDocument: JsonApiMetricInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, objectId, jsonApiMetricInDocument, predicate, filter, include } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityMetrics", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityMetrics", "objectId", objectId);
            // verify required parameter 'jsonApiMetricInDocument' is not null or undefined
            assertParamExists("updateEntityMetrics", "jsonApiMetricInDocument", jsonApiMetricInDocument);
            const localVarPath = `/api/entities/workspaces/{workspaceId}/metrics/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiMetricInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiMetricInDocument !== undefined ? jsonApiMetricInDocument : {})
                : jsonApiMetricInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations(
            params: {
                id: string;
                jsonApiOrganizationInDocument: JsonApiOrganizationInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiOrganizationInDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityOrganizations", "id", id);
            // verify required parameter 'jsonApiOrganizationInDocument' is not null or undefined
            assertParamExists(
                "updateEntityOrganizations",
                "jsonApiOrganizationInDocument",
                jsonApiOrganizationInDocument,
            );
            const localVarPath = `/api/entities/admin/organizations/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiOrganizationInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiOrganizationInDocument !== undefined ? jsonApiOrganizationInDocument : {},
                  )
                : jsonApiOrganizationInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups(
            params: {
                id: string;
                jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiUserGroupInDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUserGroups", "id", id);
            // verify required parameter 'jsonApiUserGroupInDocument' is not null or undefined
            assertParamExists(
                "updateEntityUserGroups",
                "jsonApiUserGroupInDocument",
                jsonApiUserGroupInDocument,
            );
            const localVarPath = `/api/entities/userGroups/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiUserGroupInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserGroupInDocument !== undefined ? jsonApiUserGroupInDocument : {})
                : jsonApiUserGroupInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers(
            params: {
                id: string;
                jsonApiUserInDocument: JsonApiUserInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiUserInDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityUsers", "id", id);
            // verify required parameter 'jsonApiUserInDocument' is not null or undefined
            assertParamExists("updateEntityUsers", "jsonApiUserInDocument", jsonApiUserInDocument);
            const localVarPath = `/api/entities/users/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiUserInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiUserInDocument !== undefined ? jsonApiUserInDocument : {})
                : jsonApiUserInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                objectId,
                jsonApiVisualizationObjectInDocument,
                predicate,
                filter,
                include,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityVisualizationObjects", "objectId", objectId);
            // verify required parameter 'jsonApiVisualizationObjectInDocument' is not null or undefined
            assertParamExists(
                "updateEntityVisualizationObjects",
                "jsonApiVisualizationObjectInDocument",
                jsonApiVisualizationObjectInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/visualizationObjects/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiVisualizationObjectInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiVisualizationObjectInDocument !== undefined
                          ? jsonApiVisualizationObjectInDocument
                          : {},
                  )
                : jsonApiVisualizationObjectInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                objectId,
                jsonApiWorkspaceDataFilterInDocument,
                predicate,
                filter,
                include,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "workspaceId", workspaceId);
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists("updateEntityWorkspaceDataFilters", "objectId", objectId);
            // verify required parameter 'jsonApiWorkspaceDataFilterInDocument' is not null or undefined
            assertParamExists(
                "updateEntityWorkspaceDataFilters",
                "jsonApiWorkspaceDataFilterInDocument",
                jsonApiWorkspaceDataFilterInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{workspaceId}/workspaceDataFilters/{objectId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiWorkspaceDataFilterInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      jsonApiWorkspaceDataFilterInDocument !== undefined
                          ? jsonApiWorkspaceDataFilterInDocument
                          : {},
                  )
                : jsonApiWorkspaceDataFilterInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces(
            params: {
                id: string;
                jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options: any = {},
        ): RequestArgs {
            const { id, jsonApiWorkspaceInDocument, predicate, filter, include } = params;
            // verify required parameter 'id' is not null or undefined
            assertParamExists("updateEntityWorkspaces", "id", id);
            // verify required parameter 'jsonApiWorkspaceInDocument' is not null or undefined
            assertParamExists(
                "updateEntityWorkspaces",
                "jsonApiWorkspaceInDocument",
                jsonApiWorkspaceInDocument,
            );
            const localVarPath = `/api/entities/workspaces/{id}`.replace(
                `{${"id"}}`,
                encodeURIComponent(String(id)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (predicate !== undefined) {
                if (typeof predicate === "object") {
                    addFlattenedObjectTo(predicate, localVarQueryParameter);
                } else {
                    localVarQueryParameter["predicate"] = predicate;
                }
            }

            if (filter !== undefined) {
                if (typeof filter === "object") {
                    addFlattenedObjectTo(filter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["filter"] = filter;
                }
            }

            if (include) {
                localVarQueryParameter["include"] = include.join(COLLECTION_FORMATS.csv);
            }

            localVarHeaderParameter["Content-Type"] = "application/vnd.gooddata.api+json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof jsonApiWorkspaceInDocument !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(jsonApiWorkspaceInDocument !== undefined ? jsonApiWorkspaceInDocument : {})
                : jsonApiWorkspaceInDocument || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).createEntityAnalyticalDashboards(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens(
            params: {
                userId: string;
                jsonApiApiTokenInDocument: JsonApiApiTokenInDocument;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiApiTokenOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityApiTokens(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins(
            params: {
                workspaceId: string;
                jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDashboardPluginOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).createEntityDashboardPlugins(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources(
            params: {
                jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityDataSources(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts(
            params: {
                workspaceId: string;
                jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFilterContextOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityFilterContexts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics(
            params: {
                workspaceId: string;
                jsonApiMetricInDocument: JsonApiMetricInDocument;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiMetricOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityMetrics(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups(
            params: {
                jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserGroupOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityUserGroups(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers(
            params: {
                jsonApiUserInDocument: JsonApiUserInDocument;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityUsers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects(
            params: {
                workspaceId: string;
                jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).createEntityVisualizationObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).createEntityWorkspaceDataFilters(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces(
            params: {
                jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).createEntityWorkspaces(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).deleteEntityAnalyticalDashboards(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens(
            params: {
                userId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityApiTokens(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).deleteEntityDashboardPlugins(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityDataSources(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityFilterContexts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityMetrics(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityUserGroups(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityUsers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).deleteEntityVisualizationObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).deleteEntityWorkspaceDataFilters(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).deleteEntityWorkspaces(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAnalyticalDashboardOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesAnalyticalDashboards(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} userId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens(
            params: {
                userId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiApiTokenOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesApiTokens(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAttributeOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesAttributes(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDashboardPluginOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesDashboardPlugins(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceIdentifierOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesDataSourceIdentifiers(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables(
            params: {
                dataSourceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceTableOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesDataSourceTables(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesDataSources(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDatasetOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesDatasets(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "dataset" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFactOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesFacts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFilterContextOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesFilterContexts(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "attribute" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiLabelOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesLabels(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiMetricOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesMetrics(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserGroupOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesUserGroups(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesUsers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiVisualizationObjectOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesVisualizationObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (
            axios?: AxiosInstance,
            basePath?: string,
        ) => AxiosPromise<JsonApiWorkspaceDataFilterSettingOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesWorkspaceDataFilterSettings(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceDataFilterOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getAllEntitiesWorkspaceDataFilters(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceOutList> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllEntitiesWorkspaces(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getAllOptions(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getDataSourceDrivers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getEntityAnalyticalDashboards(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} userId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens(
            params: {
                userId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiApiTokenOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityApiTokens(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAttributeOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityAttributes(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (
            axios?: AxiosInstance,
            basePath?: string,
        ) => AxiosPromise<JsonApiCookieSecurityConfigurationOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getEntityCookieSecurityConfigurations(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDashboardPluginOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityDashboardPlugins(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (
            axios?: AxiosInstance,
            basePath?: string,
        ) => AxiosPromise<JsonApiDataSourceIdentifierOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getEntityDataSourceIdentifiers(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables(
            params: {
                dataSourceId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceTableOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityDataSourceTables(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityDataSources(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDatasetOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityDatasets(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "dataset" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFactOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityFacts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFilterContextOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityFilterContexts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "attribute" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiLabelOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityLabels(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiMetricOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityMetrics(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiOrganizationOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityOrganizations(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserGroupOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityUserGroups(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityUsers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getEntityVisualizationObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (
            axios?: AxiosInstance,
            basePath?: string,
        ) => AxiosPromise<JsonApiWorkspaceDataFilterSettingOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getEntityWorkspaceDataFilterSettings(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).getEntityWorkspaceDataFilters(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
                metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getEntityWorkspaces(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(
            params: {
                metaInclude?: Array<"permissions" | "all">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).getOrganization(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiAnalyticalDashboardPatchDocument: JsonApiAnalyticalDashboardPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).patchEntityAnalyticalDashboards(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiDashboardPluginPatchDocument: JsonApiDashboardPluginPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDashboardPluginOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityDashboardPlugins(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources(
            params: {
                id: string;
                jsonApiDataSourcePatchDocument: JsonApiDataSourcePatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityDataSources(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiFilterContextPatchDocument: JsonApiFilterContextPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFilterContextOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityFilterContexts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiMetricPatchDocument: JsonApiMetricPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiMetricOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityMetrics(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups(
            params: {
                id: string;
                jsonApiUserGroupPatchDocument: JsonApiUserGroupPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserGroupOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityUserGroups(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers(
            params: {
                id: string;
                jsonApiUserPatchDocument: JsonApiUserPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityUsers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiVisualizationObjectPatchDocument: JsonApiVisualizationObjectPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).patchEntityVisualizationObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiWorkspaceDataFilterPatchDocument: JsonApiWorkspaceDataFilterPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).patchEntityWorkspaceDataFilters(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces(
            params: {
                id: string;
                jsonApiWorkspacePatchDocument: JsonApiWorkspacePatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).patchEntityWorkspaces(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).updateEntityAnalyticalDashboards(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations(
            params: {
                id: string;
                jsonApiCookieSecurityConfigurationInDocument: JsonApiCookieSecurityConfigurationInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (
            axios?: AxiosInstance,
            basePath?: string,
        ) => AxiosPromise<JsonApiCookieSecurityConfigurationOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).updateEntityCookieSecurityConfigurations(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDashboardPluginOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).updateEntityDashboardPlugins(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources(
            params: {
                id: string;
                jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiDataSourceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityDataSources(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiFilterContextOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityFilterContexts(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiMetricInDocument: JsonApiMetricInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiMetricOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityMetrics(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations(
            params: {
                id: string;
                jsonApiOrganizationInDocument: JsonApiOrganizationInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiOrganizationOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityOrganizations(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups(
            params: {
                id: string;
                jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserGroupOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityUserGroups(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers(
            params: {
                id: string;
                jsonApiUserInDocument: JsonApiUserInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiUserOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityUsers(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).updateEntityVisualizationObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(
                configuration,
            ).updateEntityWorkspaceDataFilters(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces(
            params: {
                id: string;
                jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonApiWorkspaceOutDocument> {
            const localVarAxiosArgs = EntitiesApiAxiosParamCreator(configuration).updateEntityWorkspaces(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options?: any,
        ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            return EntitiesApiFp(configuration).createEntityAnalyticalDashboards(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} userId
         * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityApiTokens(
            params: {
                userId: string;
                jsonApiApiTokenInDocument: JsonApiApiTokenInDocument;
            },
            options?: any,
        ): AxiosPromise<JsonApiApiTokenOutDocument> {
            return EntitiesApiFp(configuration).createEntityApiTokens(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDashboardPlugins(
            params: {
                workspaceId: string;
                jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
            },
            options?: any,
        ): AxiosPromise<JsonApiDashboardPluginOutDocument> {
            return EntitiesApiFp(configuration).createEntityDashboardPlugins(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityDataSources(
            params: {
                jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceOutDocument> {
            return EntitiesApiFp(configuration).createEntityDataSources(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityFilterContexts(
            params: {
                workspaceId: string;
                jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiFilterContextOutDocument> {
            return EntitiesApiFp(configuration).createEntityFilterContexts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityMetrics(
            params: {
                workspaceId: string;
                jsonApiMetricInDocument: JsonApiMetricInDocument;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiMetricOutDocument> {
            return EntitiesApiFp(configuration).createEntityMetrics(params, options)(axios, basePath);
        },
        /**
         *
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUserGroups(
            params: {
                jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserGroupOutDocument> {
            return EntitiesApiFp(configuration).createEntityUserGroups(params, options)(axios, basePath);
        },
        /**
         *
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityUsers(
            params: {
                jsonApiUserInDocument: JsonApiUserInDocument;
                include?: Array<"userGroups" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserOutDocument> {
            return EntitiesApiFp(configuration).createEntityUsers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityVisualizationObjects(
            params: {
                workspaceId: string;
                jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            return EntitiesApiFp(configuration).createEntityVisualizationObjects(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            return EntitiesApiFp(configuration).createEntityWorkspaceDataFilters(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityWorkspaces(
            params: {
                jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceOutDocument> {
            return EntitiesApiFp(configuration).createEntityWorkspaces(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityAnalyticalDashboards(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} userId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityApiTokens(
            params: {
                userId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityApiTokens(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityDashboardPlugins(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityDataSources(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityDataSources(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityFilterContexts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityMetrics(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUserGroups(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityUserGroups(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityUsers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityUsers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityVisualizationObjects(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityWorkspaceDataFilters(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntityWorkspaces(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).deleteEntityWorkspaces(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAnalyticalDashboards(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiAnalyticalDashboardOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesAnalyticalDashboards(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} userId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesApiTokens(
            params: {
                userId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options?: any,
        ): AxiosPromise<JsonApiApiTokenOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesApiTokens(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesAttributes(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiAttributeOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesAttributes(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDashboardPlugins(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiDashboardPluginOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesDashboardPlugins(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceIdentifiers(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceIdentifierOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesDataSourceIdentifiers(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSourceTables(
            params: {
                dataSourceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceTableOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesDataSourceTables(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDataSources(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesDataSources(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesDatasets(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiDatasetOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesDatasets(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFacts(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "dataset" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiFactOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesFacts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesFilterContexts(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiFilterContextOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesFilterContexts(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesLabels(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "attribute" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiLabelOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesLabels(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesMetrics(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiMetricOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesMetrics(params, options)(axios, basePath);
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUserGroups(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserGroupOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesUserGroups(params, options)(axios, basePath);
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesUsers(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesUsers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesVisualizationObjects(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiVisualizationObjectOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesVisualizationObjects(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilterSettings(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterSettingOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesWorkspaceDataFilterSettings(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaceDataFilters(
            params: {
                workspaceId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesWorkspaceDataFilters(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEntitiesWorkspaces(
            params: {
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
                page?: number;
                size?: number;
                sort?: Array<string>;
                metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceOutList> {
            return EntitiesApiFp(configuration).getAllEntitiesWorkspaces(params, options)(axios, basePath);
        },
        /**
         * Retrieves links for all options for different configurations.
         * @summary Links for all configuration options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOptions(params: {}, options?: any): AxiosPromise<void> {
            return EntitiesApiFp(configuration).getAllOptions(params, options)(axios, basePath);
        },
        /**
         * Retrieves a list of all supported data sources along with information about the used drivers.
         * @summary Get all available data source drivers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceDrivers(params: {}, options?: any): AxiosPromise<void> {
            return EntitiesApiFp(configuration).getDataSourceDrivers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            return EntitiesApiFp(configuration).getEntityAnalyticalDashboards(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} userId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityApiTokens(
            params: {
                userId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiApiTokenOutDocument> {
            return EntitiesApiFp(configuration).getEntityApiTokens(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityAttributes(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiAttributeOutDocument> {
            return EntitiesApiFp(configuration).getEntityAttributes(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityCookieSecurityConfigurations(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiCookieSecurityConfigurationOutDocument> {
            return EntitiesApiFp(configuration).getEntityCookieSecurityConfigurations(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiDashboardPluginOutDocument> {
            return EntitiesApiFp(configuration).getEntityDashboardPlugins(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceIdentifiers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceIdentifierOutDocument> {
            return EntitiesApiFp(configuration).getEntityDataSourceIdentifiers(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} dataSourceId
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSourceTables(
            params: {
                dataSourceId: string;
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceTableOutDocument> {
            return EntitiesApiFp(configuration).getEntityDataSourceTables(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDataSources(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceOutDocument> {
            return EntitiesApiFp(configuration).getEntityDataSources(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityDatasets(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiDatasetOutDocument> {
            return EntitiesApiFp(configuration).getEntityDatasets(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFacts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"datasets" | "dataset" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiFactOutDocument> {
            return EntitiesApiFp(configuration).getEntityFacts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiFilterContextOutDocument> {
            return EntitiesApiFp(configuration).getEntityFilterContexts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityLabels(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "attribute" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiLabelOutDocument> {
            return EntitiesApiFp(configuration).getEntityLabels(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiMetricOutDocument> {
            return EntitiesApiFp(configuration).getEntityMetrics(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityOrganizations(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
                metaInclude?: Array<"permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiOrganizationOutDocument> {
            return EntitiesApiFp(configuration).getEntityOrganizations(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUserGroups(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserGroupOutDocument> {
            return EntitiesApiFp(configuration).getEntityUserGroups(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityUsers(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserOutDocument> {
            return EntitiesApiFp(configuration).getEntityUsers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            return EntitiesApiFp(configuration).getEntityVisualizationObjects(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilterSettings(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterSettingOutDocument> {
            return EntitiesApiFp(configuration).getEntityWorkspaceDataFilterSettings(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {boolean} [xGDCVALIDATERELATIONS]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
                xGDCVALIDATERELATIONS?: boolean;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            return EntitiesApiFp(configuration).getEntityWorkspaceDataFilters(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityWorkspaces(
            params: {
                id: string;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
                metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceOutDocument> {
            return EntitiesApiFp(configuration).getEntityWorkspaces(params, options)(axios, basePath);
        },
        /**
         * Gets a basic information about organization.
         * @summary Get current organization info
         * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(
            params: {
                metaInclude?: Array<"permissions" | "all">;
            },
            options?: any,
        ): AxiosPromise<void> {
            return EntitiesApiFp(configuration).getOrganization(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiAnalyticalDashboardPatchDocument: JsonApiAnalyticalDashboardPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options?: any,
        ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            return EntitiesApiFp(configuration).patchEntityAnalyticalDashboards(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiDashboardPluginPatchDocument: JsonApiDashboardPluginPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiDashboardPluginOutDocument> {
            return EntitiesApiFp(configuration).patchEntityDashboardPlugins(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityDataSources(
            params: {
                id: string;
                jsonApiDataSourcePatchDocument: JsonApiDataSourcePatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceOutDocument> {
            return EntitiesApiFp(configuration).patchEntityDataSources(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiFilterContextPatchDocument: JsonApiFilterContextPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiFilterContextOutDocument> {
            return EntitiesApiFp(configuration).patchEntityFilterContexts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiMetricPatchDocument: JsonApiMetricPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiMetricOutDocument> {
            return EntitiesApiFp(configuration).patchEntityMetrics(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUserGroups(
            params: {
                id: string;
                jsonApiUserGroupPatchDocument: JsonApiUserGroupPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserGroupOutDocument> {
            return EntitiesApiFp(configuration).patchEntityUserGroups(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityUsers(
            params: {
                id: string;
                jsonApiUserPatchDocument: JsonApiUserPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserOutDocument> {
            return EntitiesApiFp(configuration).patchEntityUsers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiVisualizationObjectPatchDocument: JsonApiVisualizationObjectPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            return EntitiesApiFp(configuration).patchEntityVisualizationObjects(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiWorkspaceDataFilterPatchDocument: JsonApiWorkspaceDataFilterPatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            return EntitiesApiFp(configuration).patchEntityWorkspaceDataFilters(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntityWorkspaces(
            params: {
                id: string;
                jsonApiWorkspacePatchDocument: JsonApiWorkspacePatchDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceOutDocument> {
            return EntitiesApiFp(configuration).patchEntityWorkspaces(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityAnalyticalDashboards(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<
                    | "visualizationObjects"
                    | "analyticalDashboards"
                    | "labels"
                    | "metrics"
                    | "datasets"
                    | "filterContexts"
                    | "dashboardPlugins"
                    | "ALL"
                >;
            },
            options?: any,
        ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument> {
            return EntitiesApiFp(configuration).updateEntityAnalyticalDashboards(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityCookieSecurityConfigurations(
            params: {
                id: string;
                jsonApiCookieSecurityConfigurationInDocument: JsonApiCookieSecurityConfigurationInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiCookieSecurityConfigurationOutDocument> {
            return EntitiesApiFp(configuration).updateEntityCookieSecurityConfigurations(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDashboardPlugins(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiDashboardPluginOutDocument> {
            return EntitiesApiFp(configuration).updateEntityDashboardPlugins(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityDataSources(
            params: {
                id: string;
                jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
            },
            options?: any,
        ): AxiosPromise<JsonApiDataSourceOutDocument> {
            return EntitiesApiFp(configuration).updateEntityDataSources(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityFilterContexts(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiFilterContextOutDocument> {
            return EntitiesApiFp(configuration).updateEntityFilterContexts(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityMetrics(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiMetricInDocument: JsonApiMetricInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiMetricOutDocument> {
            return EntitiesApiFp(configuration).updateEntityMetrics(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityOrganizations(
            params: {
                id: string;
                jsonApiOrganizationInDocument: JsonApiOrganizationInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiOrganizationOutDocument> {
            return EntitiesApiFp(configuration).updateEntityOrganizations(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUserGroups(
            params: {
                id: string;
                jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "parents" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserGroupOutDocument> {
            return EntitiesApiFp(configuration).updateEntityUserGroups(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiUserInDocument} jsonApiUserInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityUsers(
            params: {
                id: string;
                jsonApiUserInDocument: JsonApiUserInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"userGroups" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiUserOutDocument> {
            return EntitiesApiFp(configuration).updateEntityUsers(params, options)(axios, basePath);
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityVisualizationObjects(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiVisualizationObjectOutDocument> {
            return EntitiesApiFp(configuration).updateEntityVisualizationObjects(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} workspaceId
         * @param {string} objectId
         * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaceDataFilters(
            params: {
                workspaceId: string;
                objectId: string;
                jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument> {
            return EntitiesApiFp(configuration).updateEntityWorkspaceDataFilters(params, options)(
                axios,
                basePath,
            );
        },
        /**
         *
         * @param {string} id
         * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
         * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
         * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
         * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntityWorkspaces(
            params: {
                id: string;
                jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
                predicate?: { [key: string]: object };
                filter?: string;
                include?: Array<"workspaces" | "parent" | "ALL">;
            },
            options?: any,
        ): AxiosPromise<JsonApiWorkspaceOutDocument> {
            return EntitiesApiFp(configuration).updateEntityWorkspaces(params, options)(axios, basePath);
        },
    };
};

/**
 * EntitiesApi - interface
 * @export
 * @interface EntitiesApi
 */
export interface EntitiesApiInterface {
    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
        },
        options?: any,
    ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument>;

    /**
     *
     * @param {string} userId
     * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityApiTokens(
        params: {
            userId: string;
            jsonApiApiTokenInDocument: JsonApiApiTokenInDocument;
        },
        options?: any,
    ): AxiosPromise<JsonApiApiTokenOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityDashboardPlugins(
        params: {
            workspaceId: string;
            jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
        },
        options?: any,
    ): AxiosPromise<JsonApiDashboardPluginOutDocument>;

    /**
     *
     * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityDataSources(
        params: {
            jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityFilterContexts(
        params: {
            workspaceId: string;
            jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiFilterContextOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityMetrics(
        params: {
            workspaceId: string;
            jsonApiMetricInDocument: JsonApiMetricInDocument;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiMetricOutDocument>;

    /**
     *
     * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityUserGroups(
        params: {
            jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserGroupOutDocument>;

    /**
     *
     * @param {JsonApiUserInDocument} jsonApiUserInDocument
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityUsers(
        params: {
            jsonApiUserInDocument: JsonApiUserInDocument;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityVisualizationObjects(
        params: {
            workspaceId: string;
            jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiVisualizationObjectOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument>;

    /**
     *
     * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    createEntityWorkspaces(
        params: {
            jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
            include?: Array<"workspaces" | "parent" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} userId
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityApiTokens(
        params: {
            userId: string;
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityDataSources(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityUserGroups(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityUsers(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    deleteEntityWorkspaces(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesAnalyticalDashboards(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiAnalyticalDashboardOutList>;

    /**
     *
     * @param {string} userId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesApiTokens(
        params: {
            userId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ): AxiosPromise<JsonApiApiTokenOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesAttributes(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiAttributeOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesDashboardPlugins(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiDashboardPluginOutList>;

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesDataSourceIdentifiers(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceIdentifierOutList>;

    /**
     *
     * @param {string} dataSourceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesDataSourceTables(
        params: {
            dataSourceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceTableOutList>;

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesDataSources(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesDatasets(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiDatasetOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesFacts(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "dataset" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiFactOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesFilterContexts(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiFilterContextOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesLabels(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "attribute" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiLabelOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesMetrics(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiMetricOutList>;

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesUserGroups(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserGroupOutList>;

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesUsers(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesVisualizationObjects(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiVisualizationObjectOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesWorkspaceDataFilterSettings(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterSettingOutList>;

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesWorkspaceDataFilters(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterOutList>;

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllEntitiesWorkspaces(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceOutList>;

    /**
     * Retrieves links for all options for different configurations.
     * @summary Links for all configuration options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getAllOptions(params: {}, options?: any): AxiosPromise<void>;

    /**
     * Retrieves a list of all supported data sources along with information about the used drivers.
     * @summary Get all available data source drivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getDataSourceDrivers(params: {}, options?: any): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument>;

    /**
     *
     * @param {string} userId
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityApiTokens(
        params: {
            userId: string;
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiApiTokenOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityAttributes(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiAttributeOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityCookieSecurityConfigurations(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiCookieSecurityConfigurationOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiDashboardPluginOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityDataSourceIdentifiers(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceIdentifierOutDocument>;

    /**
     *
     * @param {string} dataSourceId
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityDataSourceTables(
        params: {
            dataSourceId: string;
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceTableOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityDataSources(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityDatasets(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiDatasetOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityFacts(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "dataset" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiFactOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiFilterContextOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityLabels(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "attribute" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiLabelOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiMetricOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityOrganizations(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiOrganizationOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityUserGroups(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserGroupOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityUsers(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiVisualizationObjectOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityWorkspaceDataFilterSettings(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterSettingOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument>;

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getEntityWorkspaces(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
            metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceOutDocument>;

    /**
     * Gets a basic information about organization.
     * @summary Get current organization info
     * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    getOrganization(
        params: {
            metaInclude?: Array<"permissions" | "all">;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiAnalyticalDashboardPatchDocument: JsonApiAnalyticalDashboardPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
        },
        options?: any,
    ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiDashboardPluginPatchDocument: JsonApiDashboardPluginPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiDashboardPluginOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityDataSources(
        params: {
            id: string;
            jsonApiDataSourcePatchDocument: JsonApiDataSourcePatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiFilterContextPatchDocument: JsonApiFilterContextPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiFilterContextOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiMetricPatchDocument: JsonApiMetricPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiMetricOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityUserGroups(
        params: {
            id: string;
            jsonApiUserGroupPatchDocument: JsonApiUserGroupPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserGroupOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityUsers(
        params: {
            id: string;
            jsonApiUserPatchDocument: JsonApiUserPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiVisualizationObjectPatchDocument: JsonApiVisualizationObjectPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiVisualizationObjectOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiWorkspaceDataFilterPatchDocument: JsonApiWorkspaceDataFilterPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    patchEntityWorkspaces(
        params: {
            id: string;
            jsonApiWorkspacePatchDocument: JsonApiWorkspacePatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
        },
        options?: any,
    ): AxiosPromise<JsonApiAnalyticalDashboardOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityCookieSecurityConfigurations(
        params: {
            id: string;
            jsonApiCookieSecurityConfigurationInDocument: JsonApiCookieSecurityConfigurationInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiCookieSecurityConfigurationOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiDashboardPluginOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityDataSources(
        params: {
            id: string;
            jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ): AxiosPromise<JsonApiDataSourceOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiFilterContextOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiMetricInDocument: JsonApiMetricInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiMetricOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityOrganizations(
        params: {
            id: string;
            jsonApiOrganizationInDocument: JsonApiOrganizationInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiOrganizationOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityUserGroups(
        params: {
            id: string;
            jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserGroupOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiUserInDocument} jsonApiUserInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityUsers(
        params: {
            id: string;
            jsonApiUserInDocument: JsonApiUserInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiUserOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiVisualizationObjectOutDocument>;

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceDataFilterOutDocument>;

    /**
     *
     * @param {string} id
     * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApiInterface
     */
    updateEntityWorkspaces(
        params: {
            id: string;
            jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
        },
        options?: any,
    ): AxiosPromise<JsonApiWorkspaceOutDocument>;
}

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI implements EntitiesApiInterface {
    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityAnalyticalDashboards(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} userId
     * @param {JsonApiApiTokenInDocument} jsonApiApiTokenInDocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityApiTokens(
        params: {
            userId: string;
            jsonApiApiTokenInDocument: JsonApiApiTokenInDocument;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityApiTokens(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityDashboardPlugins(
        params: {
            workspaceId: string;
            jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityDashboardPlugins(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityDataSources(
        params: {
            jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityDataSources(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityFilterContexts(
        params: {
            workspaceId: string;
            jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityFilterContexts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityMetrics(
        params: {
            workspaceId: string;
            jsonApiMetricInDocument: JsonApiMetricInDocument;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityMetrics(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityUserGroups(
        params: {
            jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityUserGroups(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {JsonApiUserInDocument} jsonApiUserInDocument
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityUsers(
        params: {
            jsonApiUserInDocument: JsonApiUserInDocument;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityUsers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityVisualizationObjects(
        params: {
            workspaceId: string;
            jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityVisualizationObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityWorkspaceDataFilters(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntityWorkspaces(
        params: {
            jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
            include?: Array<"workspaces" | "parent" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).createEntityWorkspaces(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityAnalyticalDashboards(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} userId
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityApiTokens(
        params: {
            userId: string;
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityApiTokens(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityDashboardPlugins(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityDataSources(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityDataSources(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityFilterContexts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityMetrics(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityUserGroups(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityUserGroups(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityUsers(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityUsers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityVisualizationObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityWorkspaceDataFilters(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntityWorkspaces(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).deleteEntityWorkspaces(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesAnalyticalDashboards(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesAnalyticalDashboards(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} userId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesApiTokens(
        params: {
            userId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesApiTokens(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesAttributes(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesAttributes(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesDashboardPlugins(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesDashboardPlugins(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesDataSourceIdentifiers(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesDataSourceIdentifiers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} dataSourceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesDataSourceTables(
        params: {
            dataSourceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesDataSourceTables(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesDataSources(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            page?: number;
            size?: number;
            sort?: Array<string>;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesDataSources(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesDatasets(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesDatasets(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesFacts(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "dataset" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesFacts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesFilterContexts(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesFilterContexts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesLabels(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "attribute" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesLabels(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesMetrics(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesMetrics(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesUserGroups(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesUserGroups(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesUsers(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesUsers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesVisualizationObjects(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesVisualizationObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesWorkspaceDataFilterSettings(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesWorkspaceDataFilterSettings(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesWorkspaceDataFilters(
        params: {
            workspaceId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesWorkspaceDataFilters(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllEntitiesWorkspaces(
        params: {
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
            page?: number;
            size?: number;
            sort?: Array<string>;
            metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getAllEntitiesWorkspaces(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieves links for all options for different configurations.
     * @summary Links for all configuration options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getAllOptions(params: {}, options?: any) {
        return EntitiesApiFp(this.configuration).getAllOptions(params, options)(this.axios, this.basePath);
    }

    /**
     * Retrieves a list of all supported data sources along with information about the used drivers.
     * @summary Get all available data source drivers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getDataSourceDrivers(params: {}, options?: any) {
        return EntitiesApiFp(this.configuration).getDataSourceDrivers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityAnalyticalDashboards(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} userId
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityApiTokens(
        params: {
            userId: string;
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityApiTokens(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'labels' | 'dataset' | 'defaultView' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityAttributes(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "labels" | "dataset" | "defaultView" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityAttributes(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityCookieSecurityConfigurations(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityCookieSecurityConfigurations(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityDashboardPlugins(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityDataSourceIdentifiers(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityDataSourceIdentifiers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} dataSourceId
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityDataSourceTables(
        params: {
            dataSourceId: string;
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityDataSourceTables(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityDataSources(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityDataSources(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'facts' | 'datasets' | 'references' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityDatasets(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "facts" | "datasets" | "references" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityDatasets(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'datasets' | 'dataset' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityFacts(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"datasets" | "dataset" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityFacts(params, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityFilterContexts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'attribute' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityLabels(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "attribute" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityLabels(params, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityMetrics(params, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {Array<'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityOrganizations(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
            metaInclude?: Array<"permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityOrganizations(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityUserGroups(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityUserGroups(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityUsers(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityUsers(params, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityVisualizationObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilters' | 'workspaceDataFilter' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityWorkspaceDataFilterSettings(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilters" | "workspaceDataFilter" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityWorkspaceDataFilterSettings(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {boolean} [xGDCVALIDATERELATIONS]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
            xGDCVALIDATERELATIONS?: boolean;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityWorkspaceDataFilters(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {Array<'config' | 'permissions' | 'all' | 'ALL'>} [metaInclude] Include Meta objects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntityWorkspaces(
        params: {
            id: string;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
            metaInclude?: Array<"config" | "permissions" | "all" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getEntityWorkspaces(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Gets a basic information about organization.
     * @summary Get current organization info
     * @param {Array<'permissions' | 'all'>} [metaInclude] Return list of permissions available to logged user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getOrganization(
        params: {
            metaInclude?: Array<"permissions" | "all">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).getOrganization(params, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiAnalyticalDashboardPatchDocument} jsonApiAnalyticalDashboardPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiAnalyticalDashboardPatchDocument: JsonApiAnalyticalDashboardPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityAnalyticalDashboards(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiDashboardPluginPatchDocument} jsonApiDashboardPluginPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiDashboardPluginPatchDocument: JsonApiDashboardPluginPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityDashboardPlugins(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiDataSourcePatchDocument} jsonApiDataSourcePatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityDataSources(
        params: {
            id: string;
            jsonApiDataSourcePatchDocument: JsonApiDataSourcePatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityDataSources(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiFilterContextPatchDocument} jsonApiFilterContextPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiFilterContextPatchDocument: JsonApiFilterContextPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityFilterContexts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiMetricPatchDocument} jsonApiMetricPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiMetricPatchDocument: JsonApiMetricPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityMetrics(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiUserGroupPatchDocument} jsonApiUserGroupPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityUserGroups(
        params: {
            id: string;
            jsonApiUserGroupPatchDocument: JsonApiUserGroupPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityUserGroups(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiUserPatchDocument} jsonApiUserPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityUsers(
        params: {
            id: string;
            jsonApiUserPatchDocument: JsonApiUserPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityUsers(params, options)(this.axios, this.basePath);
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiVisualizationObjectPatchDocument} jsonApiVisualizationObjectPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiVisualizationObjectPatchDocument: JsonApiVisualizationObjectPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityVisualizationObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiWorkspaceDataFilterPatchDocument} jsonApiWorkspaceDataFilterPatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiWorkspaceDataFilterPatchDocument: JsonApiWorkspaceDataFilterPatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityWorkspaceDataFilters(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiWorkspacePatchDocument} jsonApiWorkspacePatchDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntityWorkspaces(
        params: {
            id: string;
            jsonApiWorkspacePatchDocument: JsonApiWorkspacePatchDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).patchEntityWorkspaces(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiAnalyticalDashboardInDocument} jsonApiAnalyticalDashboardInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'visualizationObjects' | 'analyticalDashboards' | 'labels' | 'metrics' | 'datasets' | 'filterContexts' | 'dashboardPlugins' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityAnalyticalDashboards(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiAnalyticalDashboardInDocument: JsonApiAnalyticalDashboardInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<
                | "visualizationObjects"
                | "analyticalDashboards"
                | "labels"
                | "metrics"
                | "datasets"
                | "filterContexts"
                | "dashboardPlugins"
                | "ALL"
            >;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityAnalyticalDashboards(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiCookieSecurityConfigurationInDocument} jsonApiCookieSecurityConfigurationInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityCookieSecurityConfigurations(
        params: {
            id: string;
            jsonApiCookieSecurityConfigurationInDocument: JsonApiCookieSecurityConfigurationInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityCookieSecurityConfigurations(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiDashboardPluginInDocument} jsonApiDashboardPluginInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityDashboardPlugins(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiDashboardPluginInDocument: JsonApiDashboardPluginInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityDashboardPlugins(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiDataSourceInDocument} jsonApiDataSourceInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityDataSources(
        params: {
            id: string;
            jsonApiDataSourceInDocument: JsonApiDataSourceInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityDataSources(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiFilterContextInDocument} jsonApiFilterContextInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'attributes' | 'datasets' | 'labels' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityFilterContexts(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiFilterContextInDocument: JsonApiFilterContextInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"attributes" | "datasets" | "labels" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityFilterContexts(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiMetricInDocument} jsonApiMetricInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityMetrics(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiMetricInDocument: JsonApiMetricInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityMetrics(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiOrganizationInDocument} jsonApiOrganizationInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'users' | 'userGroups' | 'bootstrapUser' | 'bootstrapUserGroup' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityOrganizations(
        params: {
            id: string;
            jsonApiOrganizationInDocument: JsonApiOrganizationInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"users" | "userGroups" | "bootstrapUser" | "bootstrapUserGroup" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityOrganizations(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiUserGroupInDocument} jsonApiUserGroupInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'parents' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityUserGroups(
        params: {
            id: string;
            jsonApiUserGroupInDocument: JsonApiUserGroupInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "parents" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityUserGroups(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiUserInDocument} jsonApiUserInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'userGroups' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityUsers(
        params: {
            id: string;
            jsonApiUserInDocument: JsonApiUserInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"userGroups" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityUsers(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiVisualizationObjectInDocument} jsonApiVisualizationObjectInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'facts' | 'attributes' | 'labels' | 'metrics' | 'datasets' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityVisualizationObjects(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiVisualizationObjectInDocument: JsonApiVisualizationObjectInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"facts" | "attributes" | "labels" | "metrics" | "datasets" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityVisualizationObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} workspaceId
     * @param {string} objectId
     * @param {JsonApiWorkspaceDataFilterInDocument} jsonApiWorkspaceDataFilterInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaceDataFilterSettings' | 'filterSettings' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityWorkspaceDataFilters(
        params: {
            workspaceId: string;
            objectId: string;
            jsonApiWorkspaceDataFilterInDocument: JsonApiWorkspaceDataFilterInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaceDataFilterSettings" | "filterSettings" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityWorkspaceDataFilters(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {string} id
     * @param {JsonApiWorkspaceInDocument} jsonApiWorkspaceInDocument
     * @param {{ [key: string]: object; }} [predicate] Composed query parameters used for filtering. \&#39;id\&#39; parameter can be used for all objects. Other parameters are present according to object type (title, description,...). You can specify any object parameter and parameter of related entity up to 2nd level (for example name&#x3D;John&amp;language&#x3D;english,czech&amp;address.city&#x3D;London&amp;father.id&#x3D;123).
     * @param {string} [filter] Filtering parameter in RSQL. See https://github.com/jirutka/rsql-parser. You can specify any object parameter and parameter of related entity (for example title&#x3D;&#x3D;\&#39;Some Title\&#39;;description&#x3D;&#x3D;\&#39;desc\&#39;). Additionally, if the entity relationship represents a polymorphic entity type, it can be casted to its subtypes (for example relatedEntity::subtype.subtypeProperty&#x3D;&#x3D;\&#39;Value 123\&#39;).
     * @param {Array<'workspaces' | 'parent' | 'ALL'>} [include] Array of included collections or individual relationships. Includes are separated by commas (e.g. include&#x3D;entity1s,entity2s). Collection include represents the inclusion of every relationship between this entity and the given collection. Relationship include represents the inclusion of the particular relationships only. If single parameter \&quot;ALL\&quot; is present, all possible includes are used (include&#x3D;ALL).  __WARNING:__ Individual include types (collection, relationship or ALL) cannot be combined together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public updateEntityWorkspaces(
        params: {
            id: string;
            jsonApiWorkspaceInDocument: JsonApiWorkspaceInDocument;
            predicate?: { [key: string]: object };
            filter?: string;
            include?: Array<"workspaces" | "parent" | "ALL">;
        },
        options?: any,
    ) {
        return EntitiesApiFp(this.configuration).updateEntityWorkspaces(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * LayoutApi - axios parameter creator
 * @export
 */
export const LayoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getAnalyticsModel", "workspaceId", workspaceId);
            const localVarPath = `/api/layout/workspaces/{workspaceId}/analyticsModel`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/dataSources`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getLogicalModel", "workspaceId", workspaceId);
            const localVarPath = `/api/layout/workspaces/{workspaceId}/logicalModel`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/organization`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPdmLayout(
            params: {
                dataSourceId: string;
            },
            options: any = {},
        ): RequestArgs {
            const { dataSourceId } = params;
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getPdmLayout", "dataSourceId", dataSourceId);
            const localVarPath = `/api/layout/dataSources/{dataSourceId}/physicalModel`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/userGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/usersAndUserGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/workspaceDataFilters`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspaceLayout", "workspaceId", workspaceId);
            const localVarPath = `/api/layout/workspaces/{workspaceId}`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(
            params: {
                workspaceId: string;
                declarativeWorkspacePermissions: DeclarativeWorkspacePermissions;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, declarativeWorkspacePermissions } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspacePermissions", "workspaceId", workspaceId);
            // verify required parameter 'declarativeWorkspacePermissions' is not null or undefined
            assertParamExists(
                "getWorkspacePermissions",
                "declarativeWorkspacePermissions",
                declarativeWorkspacePermissions,
            );
            const localVarPath = `/api/layout/workspaces/{workspaceId}/permissions`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeWorkspacePermissions !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      declarativeWorkspacePermissions !== undefined ? declarativeWorkspacePermissions : {},
                  )
                : declarativeWorkspacePermissions || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions1(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getWorkspacePermissions1", "workspaceId", workspaceId);
            const localVarPath = `/api/layout/workspaces/{workspaceId}/permissions`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout(params: {}, options: any = {}): RequestArgs {
            const {} = params;
            const localVarPath = `/api/layout/workspaces`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout(
            params: {
                declarativeDataSources: DeclarativeDataSources;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeDataSources } = params;
            // verify required parameter 'declarativeDataSources' is not null or undefined
            assertParamExists("putDataSourcesLayout", "declarativeDataSources", declarativeDataSources);
            const localVarPath = `/api/layout/dataSources`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeDataSources !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeDataSources !== undefined ? declarativeDataSources : {})
                : declarativeDataSources || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout(
            params: {
                declarativeUserGroups: DeclarativeUserGroups;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeUserGroups } = params;
            // verify required parameter 'declarativeUserGroups' is not null or undefined
            assertParamExists("putUserGroupsLayout", "declarativeUserGroups", declarativeUserGroups);
            const localVarPath = `/api/layout/userGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeUserGroups !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUserGroups !== undefined ? declarativeUserGroups : {})
                : declarativeUserGroups || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout(
            params: {
                declarativeUsers: DeclarativeUsers;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeUsers } = params;
            // verify required parameter 'declarativeUsers' is not null or undefined
            assertParamExists("putUsersLayout", "declarativeUsers", declarativeUsers);
            const localVarPath = `/api/layout/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeUsers !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUsers !== undefined ? declarativeUsers : {})
                : declarativeUsers || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout(
            params: {
                declarativeUsersUserGroups: DeclarativeUsersUserGroups;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeUsersUserGroups } = params;
            // verify required parameter 'declarativeUsersUserGroups' is not null or undefined
            assertParamExists(
                "putUsersUserGroupsLayout",
                "declarativeUsersUserGroups",
                declarativeUsersUserGroups,
            );
            const localVarPath = `/api/layout/usersAndUserGroups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeUsersUserGroups !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeUsersUserGroups !== undefined ? declarativeUsersUserGroups : {})
                : declarativeUsersUserGroups || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout(
            params: {
                workspaceId: string;
                declarativeWorkspaceModel: DeclarativeWorkspaceModel;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, declarativeWorkspaceModel } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("putWorkspaceLayout", "workspaceId", workspaceId);
            // verify required parameter 'declarativeWorkspaceModel' is not null or undefined
            assertParamExists("putWorkspaceLayout", "declarativeWorkspaceModel", declarativeWorkspaceModel);
            const localVarPath = `/api/layout/workspaces/{workspaceId}`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeWorkspaceModel !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaceModel !== undefined ? declarativeWorkspaceModel : {})
                : declarativeWorkspaceModel || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel(
            params: {
                workspaceId: string;
                declarativeAnalytics: DeclarativeAnalytics;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, declarativeAnalytics } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setAnalyticsModel", "workspaceId", workspaceId);
            // verify required parameter 'declarativeAnalytics' is not null or undefined
            assertParamExists("setAnalyticsModel", "declarativeAnalytics", declarativeAnalytics);
            const localVarPath = `/api/layout/workspaces/{workspaceId}/analyticsModel`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeAnalytics !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeAnalytics !== undefined ? declarativeAnalytics : {})
                : declarativeAnalytics || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel(
            params: {
                workspaceId: string;
                declarativeModel: DeclarativeModel;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, declarativeModel } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("setLogicalModel", "workspaceId", workspaceId);
            // verify required parameter 'declarativeModel' is not null or undefined
            assertParamExists("setLogicalModel", "declarativeModel", declarativeModel);
            const localVarPath = `/api/layout/workspaces/{workspaceId}/logicalModel`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeModel !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeModel !== undefined ? declarativeModel : {})
                : declarativeModel || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout(
            params: {
                declarativeOrganization: DeclarativeOrganization;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeOrganization } = params;
            // verify required parameter 'declarativeOrganization' is not null or undefined
            assertParamExists("setOrganizationLayout", "declarativeOrganization", declarativeOrganization);
            const localVarPath = `/api/layout/organization`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeOrganization !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeOrganization !== undefined ? declarativeOrganization : {})
                : declarativeOrganization || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPdmLayout(
            params: {
                dataSourceId: string;
                declarativePdm: DeclarativePdm;
            },
            options: any = {},
        ): RequestArgs {
            const { dataSourceId, declarativePdm } = params;
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("setPdmLayout", "dataSourceId", dataSourceId);
            // verify required parameter 'declarativePdm' is not null or undefined
            assertParamExists("setPdmLayout", "declarativePdm", declarativePdm);
            const localVarPath = `/api/layout/dataSources/{dataSourceId}/physicalModel`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativePdm !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativePdm !== undefined ? declarativePdm : {})
                : declarativePdm || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout(
            params: {
                declarativeWorkspaceDataFilters: DeclarativeWorkspaceDataFilters;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeWorkspaceDataFilters } = params;
            // verify required parameter 'declarativeWorkspaceDataFilters' is not null or undefined
            assertParamExists(
                "setWorkspaceDataFiltersLayout",
                "declarativeWorkspaceDataFilters",
                declarativeWorkspaceDataFilters,
            );
            const localVarPath = `/api/layout/workspaceDataFilters`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeWorkspaceDataFilters !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      declarativeWorkspaceDataFilters !== undefined ? declarativeWorkspaceDataFilters : {},
                  )
                : declarativeWorkspaceDataFilters || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout(
            params: {
                declarativeWorkspaces: DeclarativeWorkspaces;
            },
            options: any = {},
        ): RequestArgs {
            const { declarativeWorkspaces } = params;
            // verify required parameter 'declarativeWorkspaces' is not null or undefined
            assertParamExists("setWorkspacesLayout", "declarativeWorkspaces", declarativeWorkspaces);
            const localVarPath = `/api/layout/workspaces`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof declarativeWorkspaces !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(declarativeWorkspaces !== undefined ? declarativeWorkspaces : {})
                : declarativeWorkspaces || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * LayoutApi - functional programming interface
 * @export
 */
export const LayoutApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeAnalytics> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getAnalyticsModel(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeDataSources> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getDataSourcesLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeModel> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getLogicalModel(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeOrganization> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getOrganizationLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPdmLayout(
            params: {
                dataSourceId: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativePdm> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getPdmLayout(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeUserGroups> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getUserGroupsLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeUsers> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getUsersLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeUsersUserGroups> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getUsersUserGroupsLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeWorkspaceDataFilters> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getWorkspaceDataFiltersLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeWorkspaceModel> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getWorkspaceLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(
            params: {
                workspaceId: string;
                declarativeWorkspacePermissions: DeclarativeWorkspacePermissions;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getWorkspacePermissions(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions1(
            params: {
                workspaceId: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeWorkspacePermissions> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getWorkspacePermissions1(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout(
            params: {},
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeclarativeWorkspaces> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).getWorkspacesLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout(
            params: {
                declarativeDataSources: DeclarativeDataSources;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).putDataSourcesLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout(
            params: {
                declarativeUserGroups: DeclarativeUserGroups;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).putUserGroupsLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout(
            params: {
                declarativeUsers: DeclarativeUsers;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).putUsersLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout(
            params: {
                declarativeUsersUserGroups: DeclarativeUsersUserGroups;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).putUsersUserGroupsLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout(
            params: {
                workspaceId: string;
                declarativeWorkspaceModel: DeclarativeWorkspaceModel;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).putWorkspaceLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel(
            params: {
                workspaceId: string;
                declarativeAnalytics: DeclarativeAnalytics;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).setAnalyticsModel(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel(
            params: {
                workspaceId: string;
                declarativeModel: DeclarativeModel;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).setLogicalModel(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout(
            params: {
                declarativeOrganization: DeclarativeOrganization;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).setOrganizationLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPdmLayout(
            params: {
                dataSourceId: string;
                declarativePdm: DeclarativePdm;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).setPdmLayout(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout(
            params: {
                declarativeWorkspaceDataFilters: DeclarativeWorkspaceDataFilters;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).setWorkspaceDataFiltersLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout(
            params: {
                declarativeWorkspaces: DeclarativeWorkspaces;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = LayoutApiAxiosParamCreator(configuration).setWorkspacesLayout(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * LayoutApi - factory interface
 * @export
 */
export const LayoutApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Retrieve current analytics model of the workspace.
         * @summary Get analytics model
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsModel(
            params: {
                workspaceId: string;
            },
            options?: any,
        ): AxiosPromise<DeclarativeAnalytics> {
            return LayoutApiFp(configuration).getAnalyticsModel(params, options)(axios, basePath);
        },
        /**
         * Retrieve all data sources including related physical model.
         * @summary Get all data sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourcesLayout(params: {}, options?: any): AxiosPromise<DeclarativeDataSources> {
            return LayoutApiFp(configuration).getDataSourcesLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve current logical model of the workspace in declarative form.
         * @summary Get logical model
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogicalModel(
            params: {
                workspaceId: string;
            },
            options?: any,
        ): AxiosPromise<DeclarativeModel> {
            return LayoutApiFp(configuration).getLogicalModel(params, options)(axios, basePath);
        },
        /**
         * Retrieve complete layout of organization, workspaces, user-groups, etc.
         * @summary Get organization layout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationLayout(params: {}, options?: any): AxiosPromise<DeclarativeOrganization> {
            return LayoutApiFp(configuration).getOrganizationLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve complete layout of tables with their columns
         * @summary Get data source physical model layout
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPdmLayout(
            params: {
                dataSourceId: string;
            },
            options?: any,
        ): AxiosPromise<DeclarativePdm> {
            return LayoutApiFp(configuration).getPdmLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve all user-groups eventually with parent group.
         * @summary Get all user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupsLayout(params: {}, options?: any): AxiosPromise<DeclarativeUserGroups> {
            return LayoutApiFp(configuration).getUserGroupsLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve all users including authentication properties.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersLayout(params: {}, options?: any): AxiosPromise<DeclarativeUsers> {
            return LayoutApiFp(configuration).getUsersLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve all users and user groups with theirs properties.
         * @summary Get all users and user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserGroupsLayout(params: {}, options?: any): AxiosPromise<DeclarativeUsersUserGroups> {
            return LayoutApiFp(configuration).getUsersUserGroupsLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve all workspaces and related workspace data filters (and their settings / values).
         * @summary Get workspace data filters for all workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDataFiltersLayout(
            params: {},
            options?: any,
        ): AxiosPromise<DeclarativeWorkspaceDataFilters> {
            return LayoutApiFp(configuration).getWorkspaceDataFiltersLayout(params, options)(axios, basePath);
        },
        /**
         * Retrieve current model of the workspace in declarative form.
         * @summary Get workspace layout
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceLayout(
            params: {
                workspaceId: string;
            },
            options?: any,
        ): AxiosPromise<DeclarativeWorkspaceModel> {
            return LayoutApiFp(configuration).getWorkspaceLayout(params, options)(axios, basePath);
        },
        /**
         * Set effective permissions for the workspace
         * @summary Set permissions for the workspace
         * @param {string} workspaceId
         * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(
            params: {
                workspaceId: string;
                declarativeWorkspacePermissions: DeclarativeWorkspacePermissions;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).getWorkspacePermissions(params, options)(axios, basePath);
        },
        /**
         * Retrieve current set of permissions of the workspace in a declarative form.
         * @summary Get permissions for the workspace
         * @param {string} workspaceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions1(
            params: {
                workspaceId: string;
            },
            options?: any,
        ): AxiosPromise<DeclarativeWorkspacePermissions> {
            return LayoutApiFp(configuration).getWorkspacePermissions1(params, options)(axios, basePath);
        },
        /**
         * Gets complete layout of workspaces, their hierarchy, models.
         * @summary Get all workspaces layout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacesLayout(params: {}, options?: any): AxiosPromise<DeclarativeWorkspaces> {
            return LayoutApiFp(configuration).getWorkspacesLayout(params, options)(axios, basePath);
        },
        /**
         * Set all data sources including related physical model.
         * @summary Put all data sources
         * @param {DeclarativeDataSources} declarativeDataSources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDataSourcesLayout(
            params: {
                declarativeDataSources: DeclarativeDataSources;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).putDataSourcesLayout(params, options)(axios, basePath);
        },
        /**
         * Define all user groups with their parents eventually.
         * @summary Put all user groups
         * @param {DeclarativeUserGroups} declarativeUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserGroupsLayout(
            params: {
                declarativeUserGroups: DeclarativeUserGroups;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).putUserGroupsLayout(params, options)(axios, basePath);
        },
        /**
         * Set all users and their authentication properties.
         * @summary Put all users
         * @param {DeclarativeUsers} declarativeUsers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersLayout(
            params: {
                declarativeUsers: DeclarativeUsers;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).putUsersLayout(params, options)(axios, basePath);
        },
        /**
         * Define all users and user groups with theirs properties.
         * @summary Put all users and user groups
         * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserGroupsLayout(
            params: {
                declarativeUsersUserGroups: DeclarativeUsersUserGroups;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).putUsersUserGroupsLayout(params, options)(axios, basePath);
        },
        /**
         * Set complete layout of workspace, like model, authorization, etc.
         * @summary Set workspace layout
         * @param {string} workspaceId
         * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWorkspaceLayout(
            params: {
                workspaceId: string;
                declarativeWorkspaceModel: DeclarativeWorkspaceModel;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).putWorkspaceLayout(params, options)(axios, basePath);
        },
        /**
         * Set effective analytics model of the workspace.
         * @summary Set analytics model
         * @param {string} workspaceId
         * @param {DeclarativeAnalytics} declarativeAnalytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAnalyticsModel(
            params: {
                workspaceId: string;
                declarativeAnalytics: DeclarativeAnalytics;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).setAnalyticsModel(params, options)(axios, basePath);
        },
        /**
         * Set effective logical model of the workspace.
         * @summary Set logical model
         * @param {string} workspaceId
         * @param {DeclarativeModel} declarativeModel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setLogicalModel(
            params: {
                workspaceId: string;
                declarativeModel: DeclarativeModel;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).setLogicalModel(params, options)(axios, basePath);
        },
        /**
         * Sets complete layout of organization, like workspaces, user-groups, etc.
         * @summary Set organization layout
         * @param {DeclarativeOrganization} declarativeOrganization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationLayout(
            params: {
                declarativeOrganization: DeclarativeOrganization;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).setOrganizationLayout(params, options)(axios, basePath);
        },
        /**
         * Sets complete layout of tables with their columns under corresponding Data Source.
         * @summary Set data source physical model layout
         * @param {string} dataSourceId
         * @param {DeclarativePdm} declarativePdm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPdmLayout(
            params: {
                dataSourceId: string;
                declarativePdm: DeclarativePdm;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).setPdmLayout(params, options)(axios, basePath);
        },
        /**
         * Sets workspace data filters in all workspaces in entire organization.
         * @summary Set all workspace data filters
         * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDataFiltersLayout(
            params: {
                declarativeWorkspaceDataFilters: DeclarativeWorkspaceDataFilters;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).setWorkspaceDataFiltersLayout(params, options)(axios, basePath);
        },
        /**
         * Sets complete layout of workspaces, their hierarchy, models.
         * @summary Set all workspaces layout
         * @param {DeclarativeWorkspaces} declarativeWorkspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspacesLayout(
            params: {
                declarativeWorkspaces: DeclarativeWorkspaces;
            },
            options?: any,
        ): AxiosPromise<void> {
            return LayoutApiFp(configuration).setWorkspacesLayout(params, options)(axios, basePath);
        },
    };
};

/**
 * LayoutApi - interface
 * @export
 * @interface LayoutApi
 */
export interface LayoutApiInterface {
    /**
     * Retrieve current analytics model of the workspace.
     * @summary Get analytics model
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getAnalyticsModel(
        params: {
            workspaceId: string;
        },
        options?: any,
    ): AxiosPromise<DeclarativeAnalytics>;

    /**
     * Retrieve all data sources including related physical model.
     * @summary Get all data sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getDataSourcesLayout(params: {}, options?: any): AxiosPromise<DeclarativeDataSources>;

    /**
     * Retrieve current logical model of the workspace in declarative form.
     * @summary Get logical model
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getLogicalModel(
        params: {
            workspaceId: string;
        },
        options?: any,
    ): AxiosPromise<DeclarativeModel>;

    /**
     * Retrieve complete layout of organization, workspaces, user-groups, etc.
     * @summary Get organization layout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getOrganizationLayout(params: {}, options?: any): AxiosPromise<DeclarativeOrganization>;

    /**
     * Retrieve complete layout of tables with their columns
     * @summary Get data source physical model layout
     * @param {string} dataSourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getPdmLayout(
        params: {
            dataSourceId: string;
        },
        options?: any,
    ): AxiosPromise<DeclarativePdm>;

    /**
     * Retrieve all user-groups eventually with parent group.
     * @summary Get all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getUserGroupsLayout(params: {}, options?: any): AxiosPromise<DeclarativeUserGroups>;

    /**
     * Retrieve all users including authentication properties.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getUsersLayout(params: {}, options?: any): AxiosPromise<DeclarativeUsers>;

    /**
     * Retrieve all users and user groups with theirs properties.
     * @summary Get all users and user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getUsersUserGroupsLayout(params: {}, options?: any): AxiosPromise<DeclarativeUsersUserGroups>;

    /**
     * Retrieve all workspaces and related workspace data filters (and their settings / values).
     * @summary Get workspace data filters for all workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getWorkspaceDataFiltersLayout(params: {}, options?: any): AxiosPromise<DeclarativeWorkspaceDataFilters>;

    /**
     * Retrieve current model of the workspace in declarative form.
     * @summary Get workspace layout
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getWorkspaceLayout(
        params: {
            workspaceId: string;
        },
        options?: any,
    ): AxiosPromise<DeclarativeWorkspaceModel>;

    /**
     * Set effective permissions for the workspace
     * @summary Set permissions for the workspace
     * @param {string} workspaceId
     * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getWorkspacePermissions(
        params: {
            workspaceId: string;
            declarativeWorkspacePermissions: DeclarativeWorkspacePermissions;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Retrieve current set of permissions of the workspace in a declarative form.
     * @summary Get permissions for the workspace
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getWorkspacePermissions1(
        params: {
            workspaceId: string;
        },
        options?: any,
    ): AxiosPromise<DeclarativeWorkspacePermissions>;

    /**
     * Gets complete layout of workspaces, their hierarchy, models.
     * @summary Get all workspaces layout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    getWorkspacesLayout(params: {}, options?: any): AxiosPromise<DeclarativeWorkspaces>;

    /**
     * Set all data sources including related physical model.
     * @summary Put all data sources
     * @param {DeclarativeDataSources} declarativeDataSources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    putDataSourcesLayout(
        params: {
            declarativeDataSources: DeclarativeDataSources;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Define all user groups with their parents eventually.
     * @summary Put all user groups
     * @param {DeclarativeUserGroups} declarativeUserGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    putUserGroupsLayout(
        params: {
            declarativeUserGroups: DeclarativeUserGroups;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Set all users and their authentication properties.
     * @summary Put all users
     * @param {DeclarativeUsers} declarativeUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    putUsersLayout(
        params: {
            declarativeUsers: DeclarativeUsers;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Define all users and user groups with theirs properties.
     * @summary Put all users and user groups
     * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    putUsersUserGroupsLayout(
        params: {
            declarativeUsersUserGroups: DeclarativeUsersUserGroups;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Set complete layout of workspace, like model, authorization, etc.
     * @summary Set workspace layout
     * @param {string} workspaceId
     * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    putWorkspaceLayout(
        params: {
            workspaceId: string;
            declarativeWorkspaceModel: DeclarativeWorkspaceModel;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Set effective analytics model of the workspace.
     * @summary Set analytics model
     * @param {string} workspaceId
     * @param {DeclarativeAnalytics} declarativeAnalytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    setAnalyticsModel(
        params: {
            workspaceId: string;
            declarativeAnalytics: DeclarativeAnalytics;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Set effective logical model of the workspace.
     * @summary Set logical model
     * @param {string} workspaceId
     * @param {DeclarativeModel} declarativeModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    setLogicalModel(
        params: {
            workspaceId: string;
            declarativeModel: DeclarativeModel;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Sets complete layout of organization, like workspaces, user-groups, etc.
     * @summary Set organization layout
     * @param {DeclarativeOrganization} declarativeOrganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    setOrganizationLayout(
        params: {
            declarativeOrganization: DeclarativeOrganization;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Sets complete layout of tables with their columns under corresponding Data Source.
     * @summary Set data source physical model layout
     * @param {string} dataSourceId
     * @param {DeclarativePdm} declarativePdm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    setPdmLayout(
        params: {
            dataSourceId: string;
            declarativePdm: DeclarativePdm;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Sets workspace data filters in all workspaces in entire organization.
     * @summary Set all workspace data filters
     * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    setWorkspaceDataFiltersLayout(
        params: {
            declarativeWorkspaceDataFilters: DeclarativeWorkspaceDataFilters;
        },
        options?: any,
    ): AxiosPromise<void>;

    /**
     * Sets complete layout of workspaces, their hierarchy, models.
     * @summary Set all workspaces layout
     * @param {DeclarativeWorkspaces} declarativeWorkspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApiInterface
     */
    setWorkspacesLayout(
        params: {
            declarativeWorkspaces: DeclarativeWorkspaces;
        },
        options?: any,
    ): AxiosPromise<void>;
}

/**
 * LayoutApi - object-oriented interface
 * @export
 * @class LayoutApi
 * @extends {BaseAPI}
 */
export class LayoutApi extends BaseAPI implements LayoutApiInterface {
    /**
     * Retrieve current analytics model of the workspace.
     * @summary Get analytics model
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getAnalyticsModel(
        params: {
            workspaceId: string;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).getAnalyticsModel(params, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve all data sources including related physical model.
     * @summary Get all data sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getDataSourcesLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getDataSourcesLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieve current logical model of the workspace in declarative form.
     * @summary Get logical model
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getLogicalModel(
        params: {
            workspaceId: string;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).getLogicalModel(params, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve complete layout of organization, workspaces, user-groups, etc.
     * @summary Get organization layout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getOrganizationLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getOrganizationLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieve complete layout of tables with their columns
     * @summary Get data source physical model layout
     * @param {string} dataSourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getPdmLayout(
        params: {
            dataSourceId: string;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).getPdmLayout(params, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve all user-groups eventually with parent group.
     * @summary Get all user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getUserGroupsLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getUserGroupsLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieve all users including authentication properties.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getUsersLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getUsersLayout(params, options)(this.axios, this.basePath);
    }

    /**
     * Retrieve all users and user groups with theirs properties.
     * @summary Get all users and user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getUsersUserGroupsLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getUsersUserGroupsLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieve all workspaces and related workspace data filters (and their settings / values).
     * @summary Get workspace data filters for all workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getWorkspaceDataFiltersLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getWorkspaceDataFiltersLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieve current model of the workspace in declarative form.
     * @summary Get workspace layout
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getWorkspaceLayout(
        params: {
            workspaceId: string;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).getWorkspaceLayout(params, options)(this.axios, this.basePath);
    }

    /**
     * Set effective permissions for the workspace
     * @summary Set permissions for the workspace
     * @param {string} workspaceId
     * @param {DeclarativeWorkspacePermissions} declarativeWorkspacePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getWorkspacePermissions(
        params: {
            workspaceId: string;
            declarativeWorkspacePermissions: DeclarativeWorkspacePermissions;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).getWorkspacePermissions(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Retrieve current set of permissions of the workspace in a declarative form.
     * @summary Get permissions for the workspace
     * @param {string} workspaceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getWorkspacePermissions1(
        params: {
            workspaceId: string;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).getWorkspacePermissions1(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Gets complete layout of workspaces, their hierarchy, models.
     * @summary Get all workspaces layout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public getWorkspacesLayout(params: {}, options?: any) {
        return LayoutApiFp(this.configuration).getWorkspacesLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Set all data sources including related physical model.
     * @summary Put all data sources
     * @param {DeclarativeDataSources} declarativeDataSources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public putDataSourcesLayout(
        params: {
            declarativeDataSources: DeclarativeDataSources;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).putDataSourcesLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Define all user groups with their parents eventually.
     * @summary Put all user groups
     * @param {DeclarativeUserGroups} declarativeUserGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public putUserGroupsLayout(
        params: {
            declarativeUserGroups: DeclarativeUserGroups;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).putUserGroupsLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Set all users and their authentication properties.
     * @summary Put all users
     * @param {DeclarativeUsers} declarativeUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public putUsersLayout(
        params: {
            declarativeUsers: DeclarativeUsers;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).putUsersLayout(params, options)(this.axios, this.basePath);
    }

    /**
     * Define all users and user groups with theirs properties.
     * @summary Put all users and user groups
     * @param {DeclarativeUsersUserGroups} declarativeUsersUserGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public putUsersUserGroupsLayout(
        params: {
            declarativeUsersUserGroups: DeclarativeUsersUserGroups;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).putUsersUserGroupsLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Set complete layout of workspace, like model, authorization, etc.
     * @summary Set workspace layout
     * @param {string} workspaceId
     * @param {DeclarativeWorkspaceModel} declarativeWorkspaceModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public putWorkspaceLayout(
        params: {
            workspaceId: string;
            declarativeWorkspaceModel: DeclarativeWorkspaceModel;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).putWorkspaceLayout(params, options)(this.axios, this.basePath);
    }

    /**
     * Set effective analytics model of the workspace.
     * @summary Set analytics model
     * @param {string} workspaceId
     * @param {DeclarativeAnalytics} declarativeAnalytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public setAnalyticsModel(
        params: {
            workspaceId: string;
            declarativeAnalytics: DeclarativeAnalytics;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).setAnalyticsModel(params, options)(this.axios, this.basePath);
    }

    /**
     * Set effective logical model of the workspace.
     * @summary Set logical model
     * @param {string} workspaceId
     * @param {DeclarativeModel} declarativeModel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public setLogicalModel(
        params: {
            workspaceId: string;
            declarativeModel: DeclarativeModel;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).setLogicalModel(params, options)(this.axios, this.basePath);
    }

    /**
     * Sets complete layout of organization, like workspaces, user-groups, etc.
     * @summary Set organization layout
     * @param {DeclarativeOrganization} declarativeOrganization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public setOrganizationLayout(
        params: {
            declarativeOrganization: DeclarativeOrganization;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).setOrganizationLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Sets complete layout of tables with their columns under corresponding Data Source.
     * @summary Set data source physical model layout
     * @param {string} dataSourceId
     * @param {DeclarativePdm} declarativePdm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public setPdmLayout(
        params: {
            dataSourceId: string;
            declarativePdm: DeclarativePdm;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).setPdmLayout(params, options)(this.axios, this.basePath);
    }

    /**
     * Sets workspace data filters in all workspaces in entire organization.
     * @summary Set all workspace data filters
     * @param {DeclarativeWorkspaceDataFilters} declarativeWorkspaceDataFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public setWorkspaceDataFiltersLayout(
        params: {
            declarativeWorkspaceDataFilters: DeclarativeWorkspaceDataFilters;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).setWorkspaceDataFiltersLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Sets complete layout of workspaces, their hierarchy, models.
     * @summary Set all workspaces layout
     * @param {DeclarativeWorkspaces} declarativeWorkspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutApi
     */
    public setWorkspacesLayout(
        params: {
            declarativeWorkspaces: DeclarativeWorkspaces;
        },
        options?: any,
    ) {
        return LayoutApiFp(this.configuration).setWorkspacesLayout(params, options)(
            this.axios,
            this.basePath,
        );
    }
}
