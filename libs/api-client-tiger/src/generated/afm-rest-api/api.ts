// (C) 2022 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { addFlattenedObjectTo, assertParamExists, createRequestFunction, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject } from './common';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     *
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter execution result.
     * @type {Array<FilterDefinition>}
     * @memberof AFM
     */
    filters: Array<FilterDefinition>;
    /**
     * Metrics to be computed.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    auxMeasures?: Array<MeasureItem>;
}
/**
 * A date filter specifying exact from and to dates.
 * @export
 * @interface AbsoluteDateFilter
 */
export interface AbsoluteDateFilter {
    /**
     *
     * @type {AbsoluteDateFilterBody}
     * @memberof AbsoluteDateFilter
     */
    absoluteDateFilter: AbsoluteDateFilterBody;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterBody
 */
export interface AbsoluteDateFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof AbsoluteDateFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof AbsoluteDateFilterBody
     */
    dataset: AfmObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBody
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBody
     */
    to: string;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterBodyAllOf
 */
export interface AbsoluteDateFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBodyAllOf
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBodyAllOf
     */
    to: string;
}
/**
 *
 * @export
 * @interface AbstractMeasureValueFilter
 */
export interface AbstractMeasureValueFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof AbstractMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof AbstractMeasureValueFilter
     */
    dimensionality?: Array<Identifier>;
}
/**
 *
 * @export
 * @interface AbstractMeasureValueFilterAllOf
 */
export interface AbstractMeasureValueFilterAllOf {
    /**
     *
     * @type {Array<Identifier>}
     * @memberof AbstractMeasureValueFilterAllOf
     */
    dimensionality?: Array<Identifier>;
}
/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
    /**
     *
     * @type {ExecutionSettings}
     * @memberof AfmExecution
     */
    settings?: ExecutionSettings;
}
/**
 *
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 * @export
 * @interface AfmObjectIdentifier
 */
export interface AfmObjectIdentifier {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AfmObjectIdentifier
     */
    identifier: ObjectIdentifier;
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

export const AfmValidObjectsQueryTypesEnum = {
    FACTS: "facts",
    ATTRIBUTES: "attributes",
    MEASURES: "measures",
    UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type AfmValidObjectsQueryTypesEnum =
    typeof AfmValidObjectsQueryTypesEnum[keyof typeof AfmValidObjectsQueryTypesEnum];

/**
 * All objects of specified types valid with respect to given AFM.
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<RestApiIdentifier>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<RestApiIdentifier>;
}
/**
 * Metric representing arithmetics between metrics.
 * @export
 * @interface ArithmeticMeasureDefinition
 */
export interface ArithmeticMeasureDefinition {
    /**
     *
     * @type {ArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ArithmeticMeasureDefinition
     */
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     * @type {Array<LocalIdentifier>}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<LocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     * @type {string}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum[keyof typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

/**
 *
 * @export
 * @interface AttributeExecutionResultHeader
 */
export interface AttributeExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof AttributeExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;

/**
 * Filter on specific set of label values.
 * @export
 * @interface AttributeFilterElements
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof AttributeFilterElements
     */
    values: Array<string>;
}
/**
 *
 * @export
 * @interface AttributeHeader
 */
export interface AttributeHeader {
    /**
     *
     * @type {AttributeHeaderAttributeHeader}
     * @memberof AttributeHeader
     */
    attributeHeader: AttributeHeaderAttributeHeader;
}
/**
 *
 * @export
 * @interface AttributeHeaderAttributeHeader
 */
export interface AttributeHeaderAttributeHeader {
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    localIdentifier: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    attribute: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    attributeName: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    label: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    labelName: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    primaryLabel: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    granularity?: AttributeHeaderAttributeHeaderGranularityEnum;
}

export const AttributeHeaderAttributeHeaderGranularityEnum = {
    YEAR: "YEAR",
    DAY: "DAY",
    HOUR: "HOUR",
    MINUTE: "MINUTE",
    QUARTER: "QUARTER",
    MONTH: "MONTH",
    WEEK: "WEEK",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
} as const;

export type AttributeHeaderAttributeHeaderGranularityEnum =
    typeof AttributeHeaderAttributeHeaderGranularityEnum[keyof typeof AttributeHeaderAttributeHeaderGranularityEnum];

/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof AttributeItem
     */
    label: AfmObjectIdentifier;
}
/**
 * Header containing the information related to attributes.
 * @export
 * @interface AttributeResultHeader
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    primaryLabelValue: string;
}
/**
 *
 * @export
 * @interface CommonAttributeFilter
 */
export interface CommonAttributeFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Identifier}
     * @memberof CommonAttributeFilter
     */
    label: Identifier;
}
/**
 *
 * @export
 * @interface CommonAttributeFilterAllOf
 */
export interface CommonAttributeFilterAllOf {
    /**
     *
     * @type {Identifier}
     * @memberof CommonAttributeFilterAllOf
     */
    label: Identifier;
}
/**
 *
 * @export
 * @interface CommonDateFilter
 */
export interface CommonDateFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonDateFilter
     */
    dataset: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonDateFilterAllOf
 */
export interface CommonDateFilterAllOf {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonDateFilterAllOf
     */
    dataset: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonFilter
 */
export interface CommonFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonFilter
     */
    applyOnResult?: boolean;
}
/**
 *
 * @export
 * @interface CommonMeasureValueFilter
 */
export interface CommonMeasureValueFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof CommonMeasureValueFilter
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Identifier}
     * @memberof CommonMeasureValueFilter
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof CommonMeasureValueFilter
     */
    treatNullValuesAs?: number;
}
/**
 *
 * @export
 * @interface CommonMeasureValueFilterAllOf
 */
export interface CommonMeasureValueFilterAllOf {
    /**
     *
     * @type {Identifier}
     * @memberof CommonMeasureValueFilterAllOf
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof CommonMeasureValueFilterAllOf
     */
    treatNullValuesAs?: number;
}
/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 * @export
 * @interface ComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilter {
    /**
     *
     * @type {ComparisonMeasureValueFilterBody}
     * @memberof ComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterBody;
}
/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterBody
 */
export interface ComparisonMeasureValueFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof ComparisonMeasureValueFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof ComparisonMeasureValueFilterBody
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Identifier}
     * @memberof ComparisonMeasureValueFilterBody
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBody
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterBody
     */
    operator: ComparisonMeasureValueFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBody
     */
    value: number;
}

export const ComparisonMeasureValueFilterBodyOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ComparisonMeasureValueFilterBodyOperatorEnum =
    typeof ComparisonMeasureValueFilterBodyOperatorEnum[keyof typeof ComparisonMeasureValueFilterBodyOperatorEnum];

/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterBodyAllOf
 */
export interface ComparisonMeasureValueFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterBodyAllOf
     */
    operator: ComparisonMeasureValueFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBodyAllOf
     */
    value: number;
}

export const ComparisonMeasureValueFilterBodyAllOfOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ComparisonMeasureValueFilterBodyAllOfOperatorEnum =
    typeof ComparisonMeasureValueFilterBodyAllOfOperatorEnum[keyof typeof ComparisonMeasureValueFilterBodyAllOfOperatorEnum];

/**
 * @type DateFilter
 * Abstract filter definition type for dates
 * @export
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;

/**
 * Single dimension description.
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of metrics.
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     * @type {string}
     * @memberof Dimension
     */
    localIdentifier?: string;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     * @type {Array<SortKeyAttribute | SortKeyValue>}
     * @memberof Dimension
     */
    sorting?: Array<SortKeyAttribute | SortKeyValue>;
}
/**
 * Contains the dimension-specific header information.
 * @export
 * @interface DimensionHeader
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     * @type {Array<HeaderGroup>}
     * @memberof DimensionHeader
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of primary label of attribute owning requested label or null if the primary label is excluded
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string;
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string;
}
/**
 *
 * @export
 * @interface ElementsRequest
 */
export interface ElementsRequest {
    /**
     * Requested label.
     * @type {string}
     * @memberof ElementsRequest
     */
    label: string;
    /**
     * Excludes items from the result that differ only by primary label * ```false``` - return items with distinct primary label * ```true``` - return items with distinct requested label
     * @type {boolean}
     * @memberof ElementsRequest
     */
    excludePrimaryLabel?: boolean;
    /**
     *
     * @type {FilterBy}
     * @memberof ElementsRequest
     */
    filterBy?: FilterBy;
    /**
     * Sort order of returned items. Items are sorted by ```label``` title. If no sort order is specified then attribute\'s ```sortDirection``` is used, which is ASC by default
     * @type {string}
     * @memberof ElementsRequest
     */
    sortOrder?: ElementsRequestSortOrderEnum;
    /**
     * Inverse filters: * ```false``` - return items matching ```patternFilter``` and ```exactFilter``` * ```true``` - return items not matching ```patternFilter``` and ```exactFilter```
     * @type {boolean}
     * @memberof ElementsRequest
     */
    complementFilter?: boolean;
    /**
     * Return only items, whose ```label``` title case insensitively contains ```filter``` as substring.
     * @type {string}
     * @memberof ElementsRequest
     */
    patternFilter?: string;
    /**
     * Return only items, whose ```label``` title exactly matches one of ```filter```.
     * @type {Array<string>}
     * @memberof ElementsRequest
     */
    exactFilter?: Array<string>;
    /**
     * Specifies percentage of source table data scanned during the computation. This field is deprecated and is no longer used during the elements computation.
     * @type {number}
     * @memberof ElementsRequest
     * @deprecated
     */
    dataSamplingPercentage?: number;
}

export const ElementsRequestSortOrderEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type ElementsRequestSortOrderEnum =
    typeof ElementsRequestSortOrderEnum[keyof typeof ElementsRequestSortOrderEnum];

/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof ElementsResponse
     */
    primaryLabel: RestApiIdentifier;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
}
/**
 *
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     *
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 *
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     *
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 * @export
 * @interface ExecutionResult
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResult
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to dimension size. Their order corresponds to the dimension order in the execution result spec.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResult
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * An array with grand totals data corresponding to grand totals definition in result spec.
     * @type {Array<ExecutionResultGrandTotal>}
     * @memberof ExecutionResult
     */
    grandTotals: Array<ExecutionResultGrandTotal>;
    /**
     *
     * @type {ExecutionResultPaging}
     * @memberof ExecutionResult
     */
    paging: ExecutionResultPaging;
}
/**
 * Contains the data related to a grand total, including the reference to localIdentifier as specified in result spec.
 * @export
 * @interface ExecutionResultGrandTotal
 */
export interface ExecutionResultGrandTotal {
    /**
     *
     * @type {object}
     * @memberof ExecutionResultGrandTotal
     */
    data: object;
    /**
     * Grand total identification within this request. The corresponding data in the result are expected to be matched using this identifier.
     * @type {string}
     * @memberof ExecutionResultGrandTotal
     */
    localIdentifier: string;
}
/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 * @export
 */
export type ExecutionResultHeader = AttributeExecutionResultHeader | MeasureExecutionResultHeader;

/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 * @export
 * @interface ExecutionResultPaging
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    total: Array<number>;
}
/**
 * Various setting affecting the process of ADM execution or its result
 * @export
 * @interface ExecutionSettings
 */
export interface ExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @type {number}
     * @memberof ExecutionSettings
     */
    dataSamplingPercentage?: number;
}
/**
 * Specifies what is used for filtering.
 * @export
 * @interface FilterBy
 */
export interface FilterBy {
    /**
     * Specifies which label is used for filtering - primary or requested.
     * @type {string}
     * @memberof FilterBy
     */
    labelType: FilterByLabelTypeEnum;
}

export const FilterByLabelTypeEnum = {
    PRIMARY: "PRIMARY",
    REQUESTED: "REQUESTED",
} as const;

export type FilterByLabelTypeEnum = typeof FilterByLabelTypeEnum[keyof typeof FilterByLabelTypeEnum];

/**
 * @type FilterDefinition
 * Abstract filter definition type
 * @export
 */
export type FilterDefinition =
    | AttributeFilter
    | DateFilter
    | InlineFilterDefinition
    | MeasureValueFilter
    | RankingFilter;

/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 * @export
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;

/**
 * Definition of a grand total. Grand total data will be computed into a separate section of the result structure so that client has more options how to visualize them.
 * @export
 * @interface GrandTotal
 */
export interface GrandTotal {
    /**
     * Grand total identification within this request. The corresponding data in the result are expected to be matched using this identifier.
     * @type {string}
     * @memberof GrandTotal
     */
    localIdentifier: string;
    /**
     * Aggregation function for grand total computation.
     * @type {string}
     * @memberof GrandTotal
     */
    function: string;
    /**
     *
     * @type {IncludedDimensions}
     * @memberof GrandTotal
     */
    includedDimensions: IncludedDimensions;
}
/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and metric groups.
 * @export
 * @interface HeaderGroup
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     * @type {Array<ExecutionResultHeader>}
     * @memberof HeaderGroup
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * @type Identifier
 * Abstract identifier type
 * @export
 */
export type Identifier = AfmObjectIdentifier | LocalIdentifier;

/**
 *
 * @export
 * @interface IncludedDimensionProps
 */
export interface IncludedDimensionProps {
    /**
     * Allows to customize for which attribute values the grand total will be computed. If the values for particular attribute are not specified then the totals for all values are computed. Note that this also covers the case of individual metrics (treated as values of the \"measureGroup\" pseudo attribute).
     * @type {{ [key: string]: Array<string>; }}
     * @memberof IncludedDimensionProps
     */
    dimensionAttributesValues: { [key: string]: Array<string> };
}
/**
 *
 * @export
 * @interface IncludedDimensions
 */
export interface IncludedDimensions {
    /**
     * Mapping specifying dimensions on which this grand total will be computed. Dimensions are referenced via their localIdentifiers. Optionally one can specify also the values (properties) of the dimensions\' attributes (see DimensionAttributesValues).
     * @type {{ [key: string]: IncludedDimensionProps; }}
     * @memberof IncludedDimensions
     */
    properties?: { [key: string]: IncludedDimensionProps };
}
/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface InlineFilterDefinition
 */
export interface InlineFilterDefinition {
    /**
     *
     * @type {InlineFilterDefinitionBody}
     * @memberof InlineFilterDefinition
     */
    inline: InlineFilterDefinitionBody;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionBody
 */
export interface InlineFilterDefinitionBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof InlineFilterDefinitionBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionBody
     */
    filter: string;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionBodyAllOf
 */
export interface InlineFilterDefinitionBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionBodyAllOf
     */
    filter: string;
}
/**
 * Metric defined by the raw MAQL query.
 * @export
 * @interface InlineMeasureDefinition
 */
export interface InlineMeasureDefinition {
    /**
     *
     * @type {InlineMeasureDefinitionInline}
     * @memberof InlineMeasureDefinition
     */
    inline: InlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineMeasureDefinitionInline
 */
export interface InlineMeasureDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 * String that uniquely identifies the metric in the context of the current AFM.
 * @export
 * @interface LocalIdentifier
 */
export interface LocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof LocalIdentifier
     */
    localIdentifier: string;
}
/**
 * @type MeasureDefinition
 * Abstract metric definition type
 * @export
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopDatasetMeasureDefinition
    | PopDateMeasureDefinition
    | SimpleMeasureDefinition;

/**
 *
 * @export
 * @interface MeasureExecutionResultHeader
 */
export interface MeasureExecutionResultHeader {
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof MeasureExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 *
 * @export
 * @interface MeasureGroupHeader
 */
export interface MeasureGroupHeader {
    /**
     *
     * @type {Array<MeasureHeaderOut>}
     * @memberof MeasureGroupHeader
     */
    measureGroupHeaders: Array<MeasureHeaderOut>;
}
/**
 *
 * @export
 * @interface MeasureHeaderOut
 */
export interface MeasureHeaderOut {
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    name?: string;
}
/**
 *
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {MeasureDefinition}
     * @memberof MeasureItem
     */
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to metrics.
 * @export
 * @interface MeasureResultHeader
 */
export interface MeasureResultHeader {
    /**
     * Metric index. Starts at 0.
     * @type {number}
     * @memberof MeasureResultHeader
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 * @export
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;

/**
 * Filter able to limit element values by label and related selected negated elements.
 * @export
 * @interface NegativeAttributeFilter
 */
export interface NegativeAttributeFilter {
    /**
     *
     * @type {NegativeAttributeFilterBody}
     * @memberof NegativeAttributeFilter
     */
    negativeAttributeFilter: NegativeAttributeFilterBody;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterBody
 */
export interface NegativeAttributeFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof NegativeAttributeFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Identifier}
     * @memberof NegativeAttributeFilterBody
     */
    label: Identifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterBody
     */
    notIn: AttributeFilterElements;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterBodyAllOf
 */
export interface NegativeAttributeFilterBodyAllOf {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterBodyAllOf
     */
    notIn: AttributeFilterElements;
}
/**
 * Identifier of LDM object determined by ID & type.
 * @export
 * @interface ObjectIdentifier
 */
export interface ObjectIdentifier {
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifier
     */
    type: string;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 *
 * @export
 * @interface PopDataset
 */
export interface PopDataset {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PopDataset
     */
    dataset: AfmObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 * @export
 * @interface PopDatasetMeasureDefinition
 */
export interface PopDatasetMeasureDefinition {
    /**
     *
     * @type {PopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof PopDatasetMeasureDefinition
     */
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDataset>}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<PopDataset>;
}
/**
 *
 * @export
 * @interface PopDate
 */
export interface PopDate {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PopDate
     */
    attribute: AfmObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 * @export
 * @interface PopDateMeasureDefinition
 */
export interface PopDateMeasureDefinition {
    /**
     *
     * @type {PopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof PopDateMeasureDefinition
     */
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDateMeasureDefinitionOverPeriodMeasure
 */
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDate>}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<PopDate>;
}
/**
 * Filter able to limit element values by label and related selected elements.
 * @export
 * @interface PositiveAttributeFilter
 */
export interface PositiveAttributeFilter {
    /**
     *
     * @type {PositiveAttributeFilterBody}
     * @memberof PositiveAttributeFilter
     */
    positiveAttributeFilter: PositiveAttributeFilterBody;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterBody
 */
export interface PositiveAttributeFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof PositiveAttributeFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Identifier}
     * @memberof PositiveAttributeFilterBody
     */
    label: Identifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterBody
     */
    in: AttributeFilterElements;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterBodyAllOf
 */
export interface PositiveAttributeFilterBodyAllOf {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterBodyAllOf
     */
    in: AttributeFilterElements;
}
/**
 * Contains information about the error.
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * An relative URI that identifies the specific occurrence of the problem. It may yield further information if dereferenced.
     * @type {string}
     * @memberof Problem
     */
    instance?: string;
    /**
     * An relative URI that identifies the problem type. When dereferenced, it should provide human-readable documentation for the problem type (e.g., using HTML).
     * @type {string}
     * @memberof Problem
     */
    type: string;
    /**
     *
     * @type {StatusType}
     * @memberof Problem
     */
    status: StatusType;
    /**
     * A short, summary of the problem type. Written in english and readable for engineers (usually not suited for non technical stakeholders and not localized).
     * @type {string}
     * @memberof Problem
     */
    title?: string;
    /**
     * Unique trace id used in open-tracing (semantics of transactions in distributed systems). Can be used to correlate client error with concrete request processing in the system.
     * @type {string}
     * @memberof Problem
     */
    traceId: string;
    /**
     * A human readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof Problem
     */
    detail?: string;
}
/**
 * Filter the result by comparing specified metric to given range of values.
 * @export
 * @interface RangeMeasureValueFilter
 */
export interface RangeMeasureValueFilter {
    /**
     *
     * @type {RangeMeasureValueFilterBody}
     * @memberof RangeMeasureValueFilter
     */
    rangeMeasureValueFilter: RangeMeasureValueFilterBody;
}
/**
 *
 * @export
 * @interface RangeMeasureValueFilterBody
 */
export interface RangeMeasureValueFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RangeMeasureValueFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RangeMeasureValueFilterBody
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Identifier}
     * @memberof RangeMeasureValueFilterBody
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterBody
     */
    operator: RangeMeasureValueFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    to: number;
}

export const RangeMeasureValueFilterBodyOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type RangeMeasureValueFilterBodyOperatorEnum =
    typeof RangeMeasureValueFilterBodyOperatorEnum[keyof typeof RangeMeasureValueFilterBodyOperatorEnum];

/**
 *
 * @export
 * @interface RangeMeasureValueFilterBodyAllOf
 */
export interface RangeMeasureValueFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    operator: RangeMeasureValueFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    to: number;
}

export const RangeMeasureValueFilterBodyAllOfOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type RangeMeasureValueFilterBodyAllOfOperatorEnum =
    typeof RangeMeasureValueFilterBodyAllOfOperatorEnum[keyof typeof RangeMeasureValueFilterBodyAllOfOperatorEnum];

/**
 * Filter the result on top/bottom N values according to given metric(s).
 * @export
 * @interface RankingFilter
 */
export interface RankingFilter {
    /**
     *
     * @type {RankingFilterBody}
     * @memberof RankingFilter
     */
    rankingFilter: RankingFilterBody;
}
/**
 *
 * @export
 * @interface RankingFilterBody
 */
export interface RankingFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RankingFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBody
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBody
     */
    measures: Array<Identifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterBody
     */
    operator: RankingFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterBody
     */
    value: number;
}

export const RankingFilterBodyOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type RankingFilterBodyOperatorEnum =
    typeof RankingFilterBodyOperatorEnum[keyof typeof RankingFilterBodyOperatorEnum];

/**
 *
 * @export
 * @interface RankingFilterBodyAllOf
 */
export interface RankingFilterBodyAllOf {
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBodyAllOf
     */
    measures: Array<Identifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterBodyAllOf
     */
    operator: RankingFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterBodyAllOf
     */
    value: number;
}

export const RankingFilterBodyAllOfOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type RankingFilterBodyAllOfOperatorEnum =
    typeof RankingFilterBodyAllOfOperatorEnum[keyof typeof RankingFilterBodyAllOfOperatorEnum];

/**
 *
 * @export
 * @interface RelativeDateFilter
 */
export interface RelativeDateFilter {
    /**
     *
     * @type {RelativeDateFilterBody}
     * @memberof RelativeDateFilter
     */
    relativeDateFilter: RelativeDateFilterBody;
}
/**
 *
 * @export
 * @interface RelativeDateFilterBody
 */
export interface RelativeDateFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RelativeDateFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof RelativeDateFilterBody
     */
    dataset: AfmObjectIdentifier;
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterBody
     */
    granularity: RelativeDateFilterBodyGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterBody
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterBody
     */
    to: number;
}

export const RelativeDateFilterBodyGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type RelativeDateFilterBodyGranularityEnum =
    typeof RelativeDateFilterBodyGranularityEnum[keyof typeof RelativeDateFilterBodyGranularityEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension.
 * @export
 * @interface RelativeDateFilterBodyAllOf
 */
export interface RelativeDateFilterBodyAllOf {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterBodyAllOf
     */
    granularity: RelativeDateFilterBodyAllOfGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterBodyAllOf
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterBodyAllOf
     */
    to: number;
}

export const RelativeDateFilterBodyAllOfGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type RelativeDateFilterBodyAllOfGranularityEnum =
    typeof RelativeDateFilterBodyAllOfGranularityEnum[keyof typeof RelativeDateFilterBodyAllOfGranularityEnum];

/**
 * Identifier of primary label of attribute owning requested label, or null if the primary label is excluded.
 * @export
 * @interface RestApiIdentifier
 */
export interface RestApiIdentifier {
    /**
     *
     * @type {string}
     * @memberof RestApiIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RestApiIdentifier
     */
    type: string;
}
/**
 *
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<MeasureGroupHeader | AttributeHeader>}
     * @memberof ResultDimension
     */
    headers: Array<MeasureGroupHeader | AttributeHeader>;
}
/**
 * Specifies how the result data will be formatted (```dimensions```) and which additional data shall be computed (```grandTotals```).
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
    /**
     *
     * @type {Array<GrandTotal>}
     * @memberof ResultSpec
     */
    grandTotals?: Array<GrandTotal>;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinition
 */
export interface SimpleMeasureDefinition {
    /**
     *
     * @type {SimpleMeasureDefinitionMeasure}
     * @memberof SimpleMeasureDefinition
     */
    measure: SimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinitionMeasure
 */
export interface SimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    item: AfmObjectIdentifier;
    /**
     * Definition of aggregation type of the metric.
     * @type {string}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<FilterDefinitionForSimpleMeasure>}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

export const SimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
} as const;

export type SimpleMeasureDefinitionMeasureAggregationEnum =
    typeof SimpleMeasureDefinitionMeasureAggregationEnum[keyof typeof SimpleMeasureDefinitionMeasureAggregationEnum];

/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */

export const SortDirection = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortDirection = typeof SortDirection[keyof typeof SortDirection];

/**
 * Sorting rule for sorting by attribute value in current dimension.
 * @export
 * @interface SortKeyAttribute
 */
export interface SortKeyAttribute {
    /**
     *
     * @type {SortKeyAttributeAttribute}
     * @memberof SortKeyAttribute
     */
    attribute: SortKeyAttributeAttribute;
}
/**
 *
 * @export
 * @interface SortKeyAttributeAttribute
 */
export interface SortKeyAttributeAttribute {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyAttributeAttribute
     */
    direction?: SortDirection;
    /**
     *
     * @type {SortType}
     * @memberof SortKeyAttributeAttribute
     */
    sortType?: SortType;
    /**
     * One of the \'Dimension.itemIdentifiers\' referencing the attribute which should be used for sorting the dimension.s
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    attributeIdentifier: string;
}
/**
 *
 * @export
 * @interface SortKeyValue
 */
export interface SortKeyValue {
    /**
     *
     * @type {SortKeyValueValue}
     * @memberof SortKeyValue
     */
    value: SortKeyValueValue;
}
/**
 *
 * @export
 * @interface SortKeyValueValue
 */
export interface SortKeyValueValue {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyValueValue
     */
    direction?: SortDirection;
    /**
     * Mapping from dimensions to data column locators. Locators for each dimension opposite to the sorted one must be specified.
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof SortKeyValueValue
     */
    dataColumnLocators: { [key: string]: { [key: string]: string } };
}
/**
 * Mechanism by which this attribute should be sorted. Available options are: - DEFAULT: sorting based on default rules (using sort column if defined, otherwise this label)  - LABEL: sorting by this label values  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)  - AREA: sorting by area (total or subtotal) corresponding to each attribute value. The area is computed by summing up all metric values in all other dimensions.
 * @export
 * @enum {string}
 */

export const SortType = {
    DEFAULT: "DEFAULT",
    LABEL: "LABEL",
    ATTRIBUTE: "ATTRIBUTE",
    AREA: "AREA",
} as const;

export type SortType = typeof SortType[keyof typeof SortType];

/**
 * The HTTP status code generated by the origin server for this occurrence of the problem.
 * @export
 * @interface StatusType
 */
export interface StatusType {
    /**
     *
     * @type {string}
     * @memberof StatusType
     */
    reasonPhrase?: string;
    /**
     *
     * @type {number}
     * @memberof StatusType
     */
    statusCode?: number;
}
/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */

export const TotalFunction = {
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MED: "MED",
} as const;

export type TotalFunction = typeof TotalFunction[keyof typeof TotalFunction];

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                } else {
                    localVarQueryParameter["offset"] = offset;
                }
            }

            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                } else {
                    localVarQueryParameter["limit"] = limit;
                }
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM) and GRPC and WDF models.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM, GRPC_MODEL, WDF, MAQL, QT, QT_SVG, OPT_QT, OPT_QT_SVG or SQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                if (typeof explainType === "object") {
                    addFlattenedObjectTo(explainType, localVarQueryParameter);
                } else {
                    localVarQueryParameter["explainType"] = explainType;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM) and GRPC and WDF models.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM, GRPC_MODEL, WDF, MAQL, QT, QT_SVG, OPT_QT, OPT_QT_SVG or SQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ActionsApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ActionsApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ActionsApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM) and GRPC and WDF models.
         * @summary AFM explain resource.
         * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ActionsApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ActionsApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeReport(
        requestParameters: ActionsApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM) and GRPC and WDF models.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    explainAFM(
        requestParameters: ActionsApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveResult(
        requestParameters: ActionsApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for computeLabelElementsPost operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeLabelElementsPostRequest
 */
export interface ActionsApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeReportRequest
 */
export interface ActionsApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidObjects operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidObjectsRequest
 */
export interface ActionsApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ActionsApi.
 * @export
 * @interface ActionsApiExplainAFMRequest
 */
export interface ActionsApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type (LDM, PDM, GRPC_MODEL, WDF, MAQL, QT, QT_SVG, OPT_QT, OPT_QT_SVG or SQL). If not specified all types are bundled in a ZIP archive.
     * @type {string}
     * @memberof ActionsApiExplainAFM
     */
    readonly explainType?: string;
}

/**
 * Request parameters for retrieveResult operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveResultRequest
 */
export interface ActionsApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly limit?: Array<number>;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeReport(requestParameters: ActionsApiComputeReportRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM) and GRPC and WDF models.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public explainAFM(requestParameters: ActionsApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveResult(requestParameters: ActionsApiRetrieveResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}
